<!DOCTYPE HTML>
<html>
  <head>
    <title>DexHand Sensing System Design - Sou Kit-Wa (Ken)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1000">

    <link rel="stylesheet" href="css/style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

    <style>
      .doc-header {
        padding-top: 6em;
        margin-bottom: 1.2em;
      }
      .page-title {
        font-size: 2.4em;
        line-height: 1.2em;
        font-weight: 600;
        margin-bottom: 0.4em;
      }
      .page-subtitle {
        color: #a0a8b0;
        line-height: 1.6em;
      }
      .back-link {
        display: inline-block;
        margin-top: 1.2em;
        margin-right: 0.8em;
        color: #146ebe;
        font-size: 1.05em;
      }
      .doc {
        margin-top: 2.0em;
        padding: 1.6em 1.8em;
        border-radius: 12px;
        border-left: 4px solid #146ebe;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      .doc h1, .doc h2, .doc h3, .doc h4 {
        color: #150c21;
        margin: 1.0em 0 0.4em 0;
        line-height: 1.35em;
      }
      .doc h1 { font-size: 2.0em; }
      .doc h2 { font-size: 1.55em; border-bottom: 2px solid rgba(20,110,190,0.25); padding-bottom: 0.35em; }
      .doc h3 { font-size: 1.25em; color: #146ebe; }
      .doc p, .doc li {
        color: #495057;
        line-height: 1.8;
      }
      .doc ul {
        list-style: disc;
        margin-left: 1.3em;
      }
      .doc ol {
        list-style: decimal;
        margin-left: 1.3em;
      }
      .doc code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.95em;
        background: rgba(15, 23, 42, 0.06);
        border: 1px solid rgba(15, 23, 42, 0.12);
        padding: 0.05em 0.35em;
        border-radius: 6px;
      }
      .doc pre code {
        display: block;
        padding: 1em 1.2em;
        overflow: auto;
        background: #0b1220;
        color: #e5e7eb;
        border: 1px solid rgba(20, 110, 190, 0.35);
        border-radius: 10px;
      }
      .doc blockquote {
        border-left: 4px solid rgba(20, 110, 190, 0.5);
        padding-left: 1em;
        margin: 1em 0;
        color: #4b5563;
      }
      .doc table {
        width: 100%;
        margin-top: 1em;
        margin-bottom: 1em;
        border: 1px solid rgba(17, 24, 39, 0.12);
        border-radius: 10px;
        overflow: hidden;
        border-collapse: collapse;
      }
      .doc th, .doc td {
        padding: 0.7em 0.8em;
        border-bottom: 1px solid rgba(17, 24, 39, 0.10);
        vertical-align: top;
        text-align: left;
      }
      .doc th {
        background: rgba(20, 110, 190, 0.08);
        font-weight: 700;
      }
      /* Primitives table: more readable and "doc-like" */
      .doc table.primitives-table {
        table-layout: fixed;
      }
      .doc table.primitives-table thead th {
        vertical-align: top;
        white-space: normal;
        line-height: 1.25;
      }
      .doc table.primitives-table .th-sub {
        display: block;
        margin-top: 0.25em;
        font-weight: 500;
        font-size: 0.88em;
        color: #6b7280;
      }
      .doc table.primitives-table tbody tr:nth-child(odd) {
        background: rgba(0, 0, 0, 0.015);
      }
      .doc table.primitives-table tbody tr:hover {
        background: rgba(20, 110, 190, 0.06);
      }
      .doc table.primitives-table td {
        word-break: break-word;
      }
      .doc table.primitives-table td:first-child,
      .doc table.primitives-table th:first-child {
        width: 10%;
      }
      .doc table.primitives-table td:first-child code {
        font-size: 0.95em;
        padding: 0.12em 0.55em;
        border-radius: 999px;
        border-color: rgba(20, 110, 190, 0.18);
        background: rgba(20, 110, 190, 0.10);
        white-space: nowrap;
      }
      .doc table.primitives-table code {
        white-space: nowrap;
      }
      .doc .toc {
        background: rgba(20,110,190,0.06);
        border: 1px solid rgba(20,110,190,0.18);
        border-radius: 10px;
        padding: 1em 1.2em;
      }

      body.dark-theme .doc {
        background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
        border-left-color: #4a9eff;
      }
      body.dark-theme .doc h1, body.dark-theme .doc h2, body.dark-theme .doc h3, body.dark-theme .doc h4 {
        color: #ffffff;
      }
      body.dark-theme .doc h2 { border-bottom-color: rgba(74, 158, 255, 0.25); }
      body.dark-theme .doc p, body.dark-theme .doc li { color: #e2e8f0; }
      body.dark-theme .page-subtitle { color: #b0b0b0; }
      body.dark-theme .doc code {
        background: rgba(148,163,184,0.15);
        border-color: rgba(148,163,184,0.25);
        color: #e2e8f0;
      }
      body.dark-theme .doc table { border-color: rgba(148,163,184,0.18); }
      body.dark-theme .doc th { background: rgba(74, 158, 255, 0.12); }
      body.dark-theme .doc th, body.dark-theme .doc td { border-bottom-color: rgba(148,163,184,0.18); }
      body.dark-theme .doc table.primitives-table tbody tr:nth-child(odd) {
        background: rgba(255, 255, 255, 0.03);
      }
      body.dark-theme .doc table.primitives-table tbody tr:hover {
        background: rgba(74, 158, 255, 0.10);
      }
      body.dark-theme .doc table.primitives-table .th-sub {
        color: #b0b0b0;
      }
      body.dark-theme .doc table.primitives-table td:first-child code {
        border-color: rgba(74, 158, 255, 0.30);
        background: rgba(74, 158, 255, 0.14);
        color: #d6ecff;
      }
      body.dark-theme .doc .toc {
        background: rgba(74,158,255,0.10);
        border-color: rgba(74,158,255,0.22);
      }
    </style>

    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body id="body">
    <div id="main">
      <div class="doc-header">
        <div class="page-title">DexHand Sensing System Design</div>
        <div class="page-subtitle">
          System design view: deployment × data × self-recovery.
        </div>
        <a class="back-link" href="index.html">&larr; Back to Home</a>
        <a class="back-link" href="blog.html">&larr; Back to Blog</a>
      </div>

      <div class="doc">
        <h1 id="dexhand-sensing-system">灵巧手 DexHand 的 Sensing System 设计（面向部署 × 采数 × 自恢复）</h1>
        <blockquote>
          <p>
            这是一份“可落地的系统设计文档”：从 <b>任务 → 力学因果 → 可观测信号 → 多频闭环 → 数据闭环（RM-in-loop）</b> 一次讲清楚，
            并给出从 MVS 到“超越人类能力”的路线图。
          </p>
        </blockquote>

        <div class="toc">
          <h2 id="toc">目录</h2>
          <ol>
            <li><a href="#core">核心三问（直击要害）</a></li>
            <li><a href="#kpi">系统目标与 KPI（把方向锁死）</a></li>
            <li><a href="#arch">总体架构（传感栈 × 多频闭环 × 数据闭环）</a></li>
            <li><a href="#stack">传感栈分层（MVS → Pro）与推荐布置</a></li>
            <li><a href="#loops">三层闭环（Level-A/B/C）与职责边界</a></li>
            <li><a href="#causality">人形视角：手是“物理因果接口”</a></li>
            <li><a href="#rm">RM-in-loop：自动切段、挑 hard cases、触发自恢复</a></li>
            <li><a href="#sync">时间同步与数据管线（可训练 / 可复现 / 可追责）</a></li>
            <li><a href="#maintain">标定、健康监测与可维护性</a></li>
            <li><a href="#roadmap">最小落地版与迭代路线图（走向超越人类）</a></li>
            <li><a href="#refs">参考链接</a></li>
          </ol>
        </div>

        <h2 id="core">核心三问（直击要害）</h2>
        <p>
          在复杂环境和大量变量中，最容易跑偏的是“堆传感器/堆模型”。从第一性原理出发，DexHand 作为“物理因果接口”，系统必须随时回答三件事：
        </p>
        <ol>
          <li><b>接触发生了吗，接触在哪里？</b>（contact geometry：接触点/接触面/面积/法向）</li>
          <li><b>接触状态是否稳定，下一段时间会不会失败？</b>（contact_mode、slip_risk、jam_risk）</li>
          <li><b>如果要恢复，应切换到哪个物理原语？</b>（primitive / recoverability：backoff、regrasp、wedge、twist…）</li>
        </ol>
        <p>
          本文的 A（Teacher→Student）+ C（RM/QC flywheel）就是围绕这三问：Research Mode 用视触觉提供高信息真值，Deploy Mode 用可部署信号近似这些真值并形成闭环。
        </p>

        <h2 id="kpi">1) 系统目标与 KPI（把方向锁死）</h2>
        <p>
          DexHand 的 sensing system 不应追求“传感器越多越好”，而应追求 <b>长时稳定 + 可自救 + 数据可复现</b>。
        </p>
        <ul>
          <li><b>稳定 KPI</b>：连续运行 \(T\) 分钟内，<code>recover_event</code> 次数、<code>human_intervention</code> 次数、<code>drop</code> 次数。</li>
          <li><b>质量 KPI</b>：同一命令流重放（Replay）可复现率（同样的 command stream → 同样的 outcome）。</li>
          <li><b>效率 KPI</b>：单位时间可采集的“有效 episode”数量（排除不可复现/不可对齐的废数据）。</li>
          <li><b>安全 KPI</b>：过流/过温/软硬限位触发次数、近碰撞次数。</li>
        </ul>
        <blockquote>
          <p>
            直觉：工程胜负手不是单次成功率，而是“长时稳定 + 快速自救 + 可复现数据飞轮”。
          </p>
        </blockquote>

        <h2 id="arch">2) 总体架构（传感栈 × 多频闭环 × 数据闭环）</h2>
        <p>三件事必须同时成立：</p>
        <ul>
          <li><b>传感栈分层</b>：高频低带宽信号兜底；少量高信息传感器负责“理解接触”。</li>
          <li><b>多频闭环分工</b>：kHz 止损、100–200Hz 防滑、5–15Hz 原语切换。</li>
          <li><b>数据闭环</b>：部署数据自动切段、打标签、挑 hard cases，再反哺训练（RM-in-loop）。</li>
        </ul>

        <pre><code>Level-C  (5–15Hz):      语义策略 / 原语切换（push/pull/wedge/twist…）
  ↓  下发参数/约束
Level-B  (60–200Hz):    触觉协调（防滑、夹持力调度、微调接触几何）
  ↓  夹持/姿态微调
Level-A  (500–1000Hz):  安全反射（限流、卡死检测、退避）

旁路数据闭环：timestamp → 对齐 → episode 切段 → RM 打分 → hard cases → 再训练</code></pre>

        <h3 id="multirate-table">2.1 多频闭环 × 传感信号：速查表</h3>
        <p>
          关键约束：视觉/视触觉的 30–120Hz 与编解码/处理延迟，无法直接承担 kHz 级闭环；因此必须分层（handbook 有详细同步与集成讨论）。
        </p>
        <table>
          <thead>
            <tr>
              <th>层级</th>
              <th>频率</th>
              <th>核心职责</th>
              <th>必需信号（建议）</th>
              <th>可选增强</th>
              <th>延迟容忍</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Level-A</b></td>
              <td>500–1000Hz</td>
              <td>安全反射/止损（限流、卡死检测、退避）</td>
              <td><code>q/qdot</code>, <code>current/effort</code>, 温度/限位/故障事件</td>
              <td>硬件触发/更高频总线（EtherCAT 等）</td>
              <td>极低（&lt;10ms）</td>
            </tr>
            <tr>
              <td><b>Level-B</b></td>
              <td>60–200Hz</td>
              <td>接触协调/防滑（夹持力调度、微调几何）</td>
              <td><code>current/effort</code>（触觉代理）, <code>q/qdot</code></td>
              <td>指尖剪切/压力阵列；耐久触觉（ITPU/霍尔/类 uSkin）；<code>wrist_FT</code></td>
              <td>中等（10–30ms）</td>
            </tr>
            <tr>
              <td><b>Level-C</b></td>
              <td>5–15Hz</td>
              <td>语义策略/原语切换（push/pull/wedge/twist…）</td>
              <td><code>rgb_static</code>, <code>rgb_wrist</code>, 任务状态</td>
              <td>视触觉特征（几何/接触模式）作为 teacher 信号</td>
              <td>高（&gt;50ms）</td>
            </tr>
          </tbody>
        </table>

        <p>设计原则（压缩成 5 条）：</p>
        <ul>
          <li><b>P1 Timestamp-at-source</b>：各模态在产生瞬间打统一时钟戳（PTP 优先）。</li>
          <li><b>P2 多频闭环</b>：不要用 30Hz 视觉硬扛 kHz 接触稳定；必须分层。</li>
          <li><b>P3 接触可观测</b>：仅 RGB 很难判断“滑 / 夹歪”；至少要有 <code>current/effort</code> 作为触觉代理。</li>
          <li><b>P4 可维护优先</b>：触觉（尤其视触觉）是易损件；维护成本会直接反噬 uptime。</li>
          <li><b>P5 先跑 MVS</b>：先做到“可复现采数 + 自恢复”，再升级传感器，而不是一开始堆满硬件。</li>
        </ul>

        <h2 id="stack">3) 传感栈分层（MVS → Pro）与推荐布置</h2>
        <p>
          这一节要解决的不是“买什么传感器”，而是：在复杂环境里，用最少的、不容易坏的信号去回答前文的<b>核心三问</b>。
          记住一个思维框架：<b>先保证可观测因果（observability），再追求更高分辨率</b>。
        </p>

        <h3 id="stack-decision">3.0 决策逻辑（为什么这样分层）</h3>
        <ul>
          <li><b>你永远需要的底座</b>：<code>q/qdot</code> + <code>current/effort</code>（高频、便宜、稳定、可回放）</li>
          <li><b>你最容易失明的因果</b>：滑移（slip）、卡死（jam）、几何偏置（misalignment）</li>
          <li><b>因此要把“信息”分两类</b>：</li>
        </ul>
        <ul>
          <li><b>闭环信息（要快）</b>：Level-A/Level-B 需要 60–1000Hz、低延迟、可长期运行 → 优先用 proprio + effort/current +（可选）wrist F/T 或耐久触觉阵列</li>
          <li><b>老师信息（要准）</b>：Research Mode 用视触觉给几何/接触模式真值 → 通过 A（Teacher→Student）蒸馏到部署可用的状态</li>
        </ul>

        <h4 id="stack-feasibility">可行性论证（为什么这套分层“真的能跑”）</h4>
        <p>
          这套分层成立的第一性原因是：<b>闭环控制需要的是“可长期、低延迟、可回放的因果信号”，而不是“看见一切几何细节”</b>。
          在长时部署里，视触觉（凝胶/表皮/光学）很难满足 uptime 与维护成本约束，因此它更适合承担“老师信息”（生成近真值标签），而不是承担“闭环主力”。
        </p>
        <p>
          你最容易失明的三类因果（slip / jam / misalignment）本质更接近<b>事件检测 + 模式切换 + 风险评估</b>问题：
          <code>q/qdot</code> 与 <code>current/effort</code> 能提供强一致的“动力学扰动证据”（可回放、可追责），再叠加（可选）<code>wrist_FT</code> 或耐久触觉阵列，就能把“止损与恢复”做得足够可靠。
          研究模式下再用视触觉给出接触几何/接触模式真值，通过 Teacher→Student 蒸馏为部署可用的状态（如 <code>slip_risk</code>、<code>jam_state</code>、<code>misalign_class</code>、<code>contact_mode</code>），从而实现<b>研究上限</b>与<b>部署稳定</b>的同时满足。
        </p>
        <p>
          <b>RM-in-loop 的关键作用</b>不是“给一个总分”，而是把连续流变成可用数据：
          自动切段、挑 hard cases、触发复核/重采样，保证 teacher 标签与部署失败代价函数对齐，避免数据飞轮被噪声带偏。
        </p>

        <h4 id="stack-conditions">成立条件清单（不满足就会翻车）</h4>
        <ul>
          <li><b>时间与回放</b>：所有关键通道必须 <b>timestamp-at-source</b>，并且可对齐回放；否则 slip/jam 的因果会被“不同步”学错。</li>
          <li><b>闭环职责边界</b>：Level-A/B 只负责“止损与恢复”（安全/防滑/解卡/退避），不承担高分辨几何重建；高分辨几何只用于 teacher。</li>
          <li><b>可部署状态定义</b>：Teacher 输出必须被压缩成部署可用、可验收的低维状态（事件/模式/风险/余量），而不是把毫米级几何硬塞进部署回路。</li>
          <li><b>恢复动作空间</b>：必须有明确的 recover primitives（如 <code>backoff</code>/<code>regrasp</code>/<code>re-approach</code> 等），并把触发条件写成规则或可学习门控；只检测不恢复等于不可用。</li>
          <li><b>域移管理</b>：Research 视触装配不能显著改变控制与摩擦边界；或训练时显式做分布对齐/随机化，否则 Teacher→Student 会学到“研究特有”的伪特征。</li>
          <li><b>传感健康是一等公民</b>：<code>sensor_health</code>/<code>calib_version</code>/<code>recalib_required</code> 必须进数据与策略输入；长期部署里“传感器退化”是常态，不建模就会默默劣化。</li>
          <li><b>验收指标绑定失败代价</b>：以误报/漏报、恢复成功率、平均止损时间、任务成功率等硬指标为准；RM 只做 triage（排序/筛选），不能替代验收。</li>
        </ul>

        <h4 id="stack-failure-mitigations">失败模式与对策（工程上最常见的坑）</h4>
        <table>
          <thead>
            <tr>
              <th>失败模式</th>
              <th>典型现象</th>
              <th>根因</th>
              <th>怎么发现（可观测信号）</th>
              <th>对策（可落地）</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Teacher/Student 标签不一致</td>
              <td>学生模型学不稳、上线后误报/漏报高</td>
              <td>标签定义不工程化（人/场景之间不一致）</td>
              <td>同一片段不同版本 teacher 输出差异大；RM 复核分歧段</td>
              <td>把标签写成“阈值 + 时间窗 + 版本号”；RM 专门挖“分歧段”做复标</td>
            </tr>
            <tr>
              <td>Research→Deploy 域移</td>
              <td>研究效果好、部署崩盘</td>
              <td>视触装配改变动力学/摩擦；或训练分布偏置</td>
              <td>部署数据上的状态分布漂移（统计特征/失败类型变了）</td>
              <td>老师只做标注不改控制边界；训练做随机化/对齐；部署端以 proprio/effort 为主</td>
            </tr>
            <tr>
              <td>多模态不同步导致“学错因果”</td>
              <td>slip/jam 预测提前/滞后，触发恢复无效</td>
              <td>相机/触觉/本体时间戳不一致，alignment 漂</td>
              <td>回放对齐后事件峰值错位；同一事件跨源延迟不稳定</td>
              <td>timestamp-at-source + 对齐校准；事件标签用窗口而不是单帧点</td>
            </tr>
            <tr>
              <td>闭环过度依赖“老师传感”</td>
              <td>视触坏了/脏了就失明</td>
              <td>把高信息但不耐久的信号当主闭环输入</td>
              <td>一旦遮挡/污染，性能断崖式下降</td>
              <td>老师信号只用于训练/标注；部署闭环只依赖可长期信号，并有健康降级路径</td>
            </tr>
            <tr>
              <td>RM 指标带偏数据飞轮</td>
              <td>数据越采越“好看但没用”</td>
              <td>RM 学到了表象特征，未对齐失败代价函数</td>
              <td>RM 高分片段并不提升部署 KPI；hard cases 被遗漏</td>
              <td>RM 只做 triage；用部署 KPI 做闭环；定期插入挑战集做校准</td>
            </tr>
            <tr>
              <td>传感器漂移/退化未建模</td>
              <td>慢性劣化、很久才被发现</td>
              <td>触觉耗材化、标定变化、线缆接触不良</td>
              <td><code>sensor_health</code> 统计漂移；失败率随时间上升</td>
              <td>把健康/标定版本写进数据；策略对健康做门控与降级；定期自动自检</td>
            </tr>
          </tbody>
        </table>

        <h3 id="mvs">3.1 Level-0（MVS：最小可行传感）</h3>
        <p>目标：低成本获得“接触判别能力 + 可复现数据”。</p>
        <ul>
          <li><b>视觉</b>：<code>rgb_static</code> + <code>rgb_wrist</code>（强烈建议腕相机）。</li>
          <li><b>本体</b>：<code>q</code>、<code>qdot</code>。</li>
          <li><b>触觉代理（必选其一）</b>：<code>motor_current</code> / <code>joint_effort</code>。</li>
          <li><b>事件信号（软件生成）</b>：<code>contact_flag</code>、<code>safety_trip</code>。</li>
        </ul>
        <p>
          这套配置已经能支撑：卡死/顶住检测、粗粒度夹持强弱闭环、Replay Validation（决定数据能不能用于训练）。
        </p>
        <p>
          <b>这背后的要害</b>：即便你“看不见接触几何”，你也要能用 <code>current/effort</code> 判断“有没有接触/有没有卡死/夹持是否在变强”。<br>
          否则部署数据会变成不可回放、不可追责的噪声。
        </p>

        <h3 id="tactile">3.2 Level-1（触觉层：让“滑移 / 接触几何”可观测）</h3>
        <p>
          这一层的目标是把两类关键信息补齐：<br>
          (1) <b>滑移/摩擦状态</b>（用于 Level-B 的防滑闭环）；<br>
          (2) <b>接触几何真值</b>（用于 Research Mode 的 teacher labels）。<br>
          为了兼顾 uptime 与信息量，推荐空间布置：<b>“2 + 1 + 1”</b>。
        </p>
        <ul>
          <li><b>2 个指尖高频剪切/压力阵列（100–200Hz）</b>：拇指 + 食指（防滑闭环主力）。</li>
          <li><b>1 个指尖高信息几何（视触觉 30–60Hz）</b>：拇指或食指（接触点/面积/边缘/微滑动）。</li>
          <li><b>1 个手腕 6D F/T（≥200Hz）</b>：推/拉/扭/撬的因果判定（外部力矩 / 约束反力）。</li>
        </ul>
        <p>
          为什么不是“全指视触觉”：全铺会把带宽、布线、耐久、标定维护成本拉爆；
          “少量高信息老师 + 少量高频工兵 + 本体信号兜底”更接近工程最优解。
        </p>
        <h4 id="placement-heuristic">布置启发式（在复杂环境里如何选“装哪里”）</h4>
        <ul>
          <li><b>先给拇指/食指</b>：它们承担最多的主动接触与相对运动（也是 slip/jam 最频发的位置）</li>
          <li><b>视触觉只当老师，不当闭环主力</b>：它输出几何/接触模式真值，用于 teacher labels；闭环仍依赖高频信号</li>
          <li><b>手腕 F/T 的价值</b>：当任务是 push/pull/twist/pry 这类“力学原语”，F/T 让因果可观测（否则只剩 current/effort 的弱 proxy）</li>
        </ul>

        <h3 id="pro">3.3 Level-2（工程化 Pro：长时部署与健康管理）</h3>
        <ul>
          <li><b>热与健康监测</b>：<code>temp_motor_i</code>、<code>over_current_count</code>、<code>stall_time_ms</code>。</li>
          <li><b>冗余观测</b>：关键关节 <code>effort/current</code> 的统计漂移，形成 <code>sensor_health</code>。</li>
        </ul>
        <p>
          <b>落地要点</b>：把“耗材化/会坏”写进系统。<br>
          视触觉（凝胶/表皮）与线缆在长期部署中就是耗材；因此需要把 <code>sensor_health</code>、<code>recalib_required</code>、以及更换后的 <code>calib_version</code> 当作数据的一等公民写进 episode metadata。
        </p>

        <h2 id="loops">4) 三层闭环（Level-A/B/C）与职责边界</h2>
        <h3 id="level-a">4.1 Level-A：安全反射层（500–1000Hz）</h3>
        <p>目标：防损坏、防卡死、防过热，毫秒级止损。</p>
        <ul>
          <li><b>输入</b>：<code>motor_current/joint_effort</code>、<code>qdot</code>、温度、软硬限位。</li>
          <li><b>输出</b>：限流、急停、退避（backoff）。</li>
        </ul>

        <h3 id="level-b">4.2 Level-B：触觉协调层（60–200Hz）</h3>
        <p>目标：防滑（slip control）、夹持力调度、微调接触几何。</p>
        <ul>
          <li><b>输入</b>：剪切/压力阵列（主力） + <code>effort/current</code>（冗余） +（可选）视触觉特征。</li>
          <li><b>输出</b>：夹持力（或关节闭合量）微调、接触姿态微调。</li>
        </ul>

        <h3 id="level-c">4.3 Level-C：语义策略层（5–15Hz）</h3>
        <p>目标：任务理解、子任务切换、与 VLA/LLM 高层决策对接。</p>
        <ul>
          <li><b>输入</b>：视觉 +（可选）语言指令/任务状态 +（可选）手腕 F/T 统计特征。</li>
          <li><b>输出</b>：子目标（grasp pose / schedule / retreat policy）以及对 A/B 的参数下发（上限、恢复路径）。</li>
        </ul>
        <blockquote>
          <p>关键点：Level-C 不直接管“接触瞬间怎么稳住”，它管的是“何时进入接触、失败后走哪条恢复路径”。</p>
        </blockquote>

        <h2 id="causality">5) 人形视角：手是“物理因果接口”</h2>
        <p>
          对人形机器人来说，手的职责是把意图转成物理世界会响应的原因（力、力矩、接触约束）。
          最小语义接口可以写成 6D wrench：
        </p>
        <p>
          \[
          w = [F_x, F_y, F_z, \tau_x, \tau_y, \tau_z]^T
          \]
        </p>
        <p>
          push/pull/press/twist/pry 本质是在控制 \(w\) 的不同分量。滑移的物理边界（简化）：
          \[
          \|f_t\| \le \mu f_n
          \]
          因而 slip detection 也是在估计：是否进入 sliding，以及离边界有多近（<code>slip_risk</code>）。
        </p>

        <h3 id="primitives">5.1 物理原语（Physical Primitives）词汇表</h3>
        <p>
          下面把文中出现的“物理原语”统一成可落地定义：每个词对应你想改变的物理量（wrench/约束/接触模式）以及它依赖的关键可观测信号。
          原语可以作为早期 <b>rule-based policy</b>，也可以作为 VLA policy 的高层动作空间（primitive switching）。
        </p>
        <table class="primitives-table">
          <colgroup>
            <col style="width: 10%;">
            <col style="width: 20%;">
            <col style="width: 18%;">
            <col style="width: 22%;">
            <col style="width: 30%;">
          </colgroup>
          <thead>
            <tr>
              <th>原语</th>
              <th>直白定义<span class="th-sub">你在物理上做什么</span></th>
              <th>目标<span class="th-sub">改变什么</span></th>
              <th>关键观测<span class="th-sub">最低配</span></th>
              <th>常见失败<span class="th-sub">触发恢复</span></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>press</code></td>
              <td>沿接触法向“压下去”，建立/维持法向力</td>
              <td>提高 \(f_n\)，增加摩擦预算（降低 slip_risk）</td>
              <td><code>current/effort</code>（法向 proxy）、<code>q/qdot</code></td>
              <td>过力/卡死（jam）→ <code>backoff</code>；滑移仍高→转 <code>wedge</code>/<code>regrasp</code></td>
            </tr>
            <tr>
              <td><code>pull</code></td>
              <td>沿某方向“拉”，尝试解除约束或拉出物体</td>
              <td>控制切向力 \(f_t\)，改变约束反力</td>
              <td><code>wrist_FT</code>（最好）、<code>current/effort</code></td>
              <td>滑移/脱手→增大 <code>press</code> 或 <code>regrasp</code></td>
            </tr>
            <tr>
              <td><code>push</code></td>
              <td>沿某方向“推”，让物体/机构进入更可控的约束状态</td>
              <td>改变接触约束与几何关系（让任务更可解）</td>
              <td><code>rgb_wrist</code> + <code>current/effort</code>（接触/阻力 proxy）</td>
              <td>顶死/卡住→ <code>backoff</code>；偏斜→ <code>re-approach</code></td>
            </tr>
            <tr>
              <td><code>wedge</code></td>
              <td>“楔入/撬开”式接触：用边缘/角点制造几何杠杆</td>
              <td>把不可见/难抓的几何变成可抓（解锁/起缝）</td>
              <td><code>wrist_FT</code>（强烈建议）、<code>current/effort</code></td>
              <td>过力/损伤风险→限力；进入 slip→转 <code>press</code>/<code>regrasp</code></td>
            </tr>
            <tr>
              <td><code>twist</code></td>
              <td>绕轴旋转（例如拧盖/旋钮）</td>
              <td>控制 \(\tau\)（扭矩）并维持接触模式为 stick</td>
              <td><code>wrist_FT</code>（最好）、<code>current/effort</code>（扭矩 proxy）</td>
              <td>滑移→先 <code>press</code> 提升摩擦；卡死→ <code>backoff</code> + 重新对齐</td>
            </tr>
            <tr>
              <td><code>pry</code></td>
              <td>“撬”：绕支点施加力矩，解除卡扣/粘连</td>
              <td>改变约束反力与接触点（高风险原语）</td>
              <td><code>wrist_FT</code>（必要）、安全限位/温度</td>
              <td>风险高：需要限力/限扭；触发 safety_trip→立刻 <code>backoff</code></td>
            </tr>
            <tr>
              <td><code>drag</code></td>
              <td>贴着表面“拖拽/扫过”以定位或产生摩擦信息</td>
              <td>用可控滑移获取信息/对齐（信息驱动原语）</td>
              <td><code>rgb_wrist</code> + <code>current/effort</code>；（有触觉更好）</td>
              <td>摩擦过大→减速/减力；抓取不稳→先 <code>press</code></td>
            </tr>
            <tr>
              <td><code>regrasp</code></td>
              <td>重新抓（松开→调整接触点→再抓）</td>
              <td>把接触几何重置到更稳定区域</td>
              <td><code>rgb_wrist</code> + <code>q/qdot</code> + <code>current/effort</code></td>
              <td>重复失败→切换 <code>wedge</code> 或改变 approach 方向</td>
            </tr>
            <tr>
              <td><code>backoff</code></td>
              <td>后退/卸载力（退避）</td>
              <td>快速止损，解除 jam/过力风险（Level-A 常用）</td>
              <td><code>current/effort</code> + <code>qdot</code> + 安全事件</td>
              <td>退避后若仍异常→标记 <code>sensor_health</code> 或请求人工介入</td>
            </tr>
            <tr>
              <td><code>reopen</code></td>
              <td>张开手指/减小夹持（释放接触）</td>
              <td>解除卡住/重置接触</td>
              <td><code>q</code> + <code>current/effort</code></td>
              <td>若释放无效→可能几何卡死，转 <code>backoff</code> + 改路径</td>
            </tr>
            <tr>
              <td><code>re-approach</code></td>
              <td>重新接近（换角度/路径再次进入接触）</td>
              <td>降低 misalignment/occlusion，获得更好接触几何</td>
              <td><code>rgb_static</code>/<code>rgb_wrist</code> + <code>q</code></td>
              <td>重复 misalignment→调整目标姿态或先 <code>drag</code> 探索</td>
            </tr>
          </tbody>
        </table>

        <h2 id="rm">6) RM-in-loop：自动切段、挑 hard cases、触发自恢复</h2>
        <p>
          把 RM 当成“质量裁判”：部署时不仅做任务，还能自动生成高价值训练数据，并减少人工介入。
        </p>
        <ul>
          <li>自动切段（streaming → episode/subtask）</li>
          <li>自动挑 hard cases（对训练最值钱）</li>
          <li>自动触发恢复策略（减少 human intervention）</li>
        </ul>
        <p>建议 RM 多头输出，而不是只输出一个标量：</p>
        <ul>
          <li><code>progress</code>、<code>quality</code>、<code>recoverability</code>、<code>failure_mode</code></li>
          <li>（强烈建议）<code>primitive</code> / <code>contact_mode</code> / <code>slip_risk</code>：把物理因果写进标签体系</li>
        </ul>

        <h2 id="sync">7) 时间同步与数据管线（可训练 / 可复现 / 可追责）</h2>
        <ul>
          <li><b>统一时钟</b>：优先 PTP（IEEE 1588），并 timestamp-at-source。</li>
          <li><b>对齐策略</b>：以视觉帧为 anchor，Ring Buffer 对齐 <code>q/qdot/effort/current/tactile</code>。</li>
          <li><b>记录两条动作流（非常重要）</b>：命令流 <code>cmd_joint_target</code> + 执行流 <code>measured_q/measured_effort</code>。</li>
        </ul>
        <p>否则你无法判断失败到底是“策略错”，还是“执行延迟/饱和/保护触发”导致的。</p>

        <h4>同步实现要点（对应 handbook）</h4>
        <ul>
          <li>
            <b>Timestamp-at-source</b> + 统一时钟（PTP/NTP）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/multimodal_data_synchronization.md" target="_blank" rel="noopener noreferrer">multimodal_data_synchronization.md</a>
          </li>
          <li>
            <b>触觉集成的延迟/布线/标定成本</b>（视触觉尤其关键）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/tactile_sensor_integration_challenges.md" target="_blank" rel="noopener noreferrer">tactile_sensor_integration_challenges.md</a>
          </li>
        </ul>

        <h3 id="two-modes">7.1 Deploy vs Research：同一套数据骨架（Deploy = 子集，Research = 超集）</h3>
        <p>
          你选择的路线是 <b>A + C</b>：用 Research Mode 的视触觉提供“高信息 teacher 信号”，但部署（Deploy Mode）不依赖视触觉的 uptime。
          因此数据要做到：<b>同一套 schema</b>，Research 只是多字段，Deploy 允许缺字段。
        </p>
        <ul>
          <li><b>Deploy Mode（长时稳定、量大）</b>：<code>rgb_static</code> / <code>rgb_wrist</code> / <code>q</code> / <code>qdot</code> / <code>current/effort</code>（+ 可选 <code>wrist_FT</code>）</li>
          <li><b>Research Mode（高分辨、高信息、量小）</b>：在 Deploy schema 上加 <code>visuotactile_img</code> / <code>tactile_depth</code> / <code>contact_patch</code> 等</li>
        </ul>

        <h4>共通字段（推荐）</h4>
        <ul>
          <li><b>动作两条流</b>：命令流 <code>cmd_joint_target</code> + 执行流 <code>measured_q</code>/<code>measured_effort</code></li>
          <li><b>episode metadata</b>：<code>task</code>、<code>calib_version</code>、<code>sync_status</code>、<code>replay_ok</code>、<code>sensor_health</code></li>
          <li><b>时间</b>：timestamp-at-source + 统一时钟 + Ring buffer 对齐（以相机为 anchor）</li>
        </ul>

        <h3 id="teacher-student">7.2 A：Teacher → Student（蒸馏到可部署信号）</h3>
        <p>
          目标：让部署侧只依赖可靠模态（RGB + proprio + current/effort + F/T），但仍能获得“类视触觉”的状态（接触模式、滑移风险、失败模式）。
          做法是：用 Research Mode 的视触觉生成 teacher labels，再训练一个只吃 Deploy 模态的 Student estimator。
        </p>
        <h4>Teacher labels（最小集合）</h4>
        <ul>
          <li><b>接触与摩擦</b>：<code>contact_mode</code>（stick/slip/roll）、<code>slip_risk</code>（0–1）、<code>contact_confidence</code></li>
          <li><b>失败语义</b>：<code>failure_mode</code>（jam/slip/occlusion/misalignment/overforce…）</li>
          <li><b>RM-in-loop</b>：<code>progress</code>、<code>quality</code>、<code>recoverability</code></li>
        </ul>
        <h4>部署侧推理（Student 输出给 policy）</h4>
        <ul>
          <li><b>输入</b>：Deploy 模态（RGB + q/qdot + current/effort + 可选 wrist_FT）</li>
          <li><b>输出</b>：teacher labels 的估计值（作为 VLA policy 的“可观测因果状态”）</li>
        </ul>

        <h4 id="state-taxonomy">7.2.1 因果状态空间（state taxonomy）：VLA 真正在学什么</h4>
        <p>
          从第一性原理出发，DexHand 不是“更复杂的夹爪”，而是机器人把语义意图转成可控的<b>物理因果</b>的接口。
          因此 policy 需要的不是“更多传感器”，而是一个可部署、可对齐、可回放的<b>因果状态</b>：
        </p>
        <ul>
          <li><b>接触几何（contact geometry）</b>：是否接触、接触点/接触面、接触面积、接触法向方向（或等价特征）</li>
          <li><b>力学因果（wrench / constraints）</b>：对物体施加的 \(w\)（或其可观测 proxy）、外部约束反力（推/拉/扭/撬）</li>
          <li><b>摩擦状态（friction state）</b>：<code>contact_mode</code>（stick/slip/roll）、<code>slip_risk</code></li>
          <li><b>失败语义（failure semantics）</b>：<code>failure_mode</code>（jam/slip/occlusion/misalignment/overforce…）</li>
          <li><b>可恢复性（recoverability）</b>：是否处于“可自救窗口”，以及推荐的恢复原语 <code>primitive</code></li>
        </ul>
        <p>
          这解释了 A（Teacher→Student）的必要性：Research Mode 的视触觉提供高信息的“因果真值”，而 Deploy Mode 则要把这些真值蒸馏成可部署信号。
        </p>

        <h4 id="teacher-labeling">7.2.2 Teacher labels 的产生机制（视触 → 标注 → 版本化）</h4>
        <p>
          这一步的目标是让 label <b>可计算、可复现、可版本化</b>，否则 teacher label 会变成不可追责的“拍脑袋标签”。
          推荐把每次生成 teacher label 的实现写成一个可追踪版本：<code>teacher_version</code>（commit hash / semantic version）+ <code>teacher_config</code>（阈值/窗口大小等）。
        </p>
        <table>
          <thead>
            <tr>
              <th>label</th>
              <th>定义（第一性）</th>
              <th>视触可计算 proxy（示例）</th>
              <th>输出形式</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>contact_confidence</code></td>
              <td>“是否接触”的置信度</td>
              <td>接触 patch 面积是否显著：<code>area(contact_patch) &gt; A_min</code></td>
              <td>0–1</td>
            </tr>
            <tr>
              <td><code>contact_patch</code></td>
              <td>接触区域（几何真值）</td>
              <td>由视触深度/形变图阈值得到二值 mask；可进一步取 centroid/主方向</td>
              <td>mask + stats</td>
            </tr>
            <tr>
              <td><code>contact_mode</code></td>
              <td>接触处于 stick/slip/roll（摩擦边界）</td>
              <td>
                <ol style="margin:0; padding-left: 1.1em;">
                  <li>若 <code>contact_confidence</code> 低 → no_contact</li>
                  <li>估计接触 patch 的切向位移/光流能量 \(v_t\)</li>
                  <li>若 \(v_t &gt; v_{slip}\) 且法向压入持续存在 → slip；否则 stick</li>
                  <li>若存在绕接触点显著旋转且切向位移小 → roll（可选）</li>
                </ol>
              </td>
              <td>枚举/one-hot</td>
            </tr>
            <tr>
              <td><code>slip_risk</code></td>
              <td>\(P(\\text{slip within }\\Delta t)\)</td>
              <td>用短窗口特征回归：<code>v_t</code>、接触面积变化、法向压入变化、effort/current 残差（如果同步）</td>
              <td>0–1</td>
            </tr>
            <tr>
              <td><code>failure_mode</code></td>
              <td>失败的物理原因分类</td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li>jam：<code>current↑</code> + <code>qdot≈0</code></li>
                  <li>slip：<code>contact_mode=slip</code></li>
                  <li>misalignment：接触 patch 偏置且 progress 停滞</li>
                  <li>occlusion：视觉/视触关键观测缺失（可选）</li>
                </ul>
              </td>
              <td>多类分类</td>
            </tr>
            <tr>
              <td><code>progress</code></td>
              <td>子任务进度（用于切段/训练）</td>
              <td>用规则或小模型：达到关键状态（接触建立、稳定抓取、旋转完成…）</td>
              <td>0–1</td>
            </tr>
            <tr>
              <td><code>recoverability</code></td>
              <td>是否处于可自救窗口</td>
              <td>failure_mode + 接触置信度 + 安全事件组合判定</td>
              <td>0–1 或 bool</td>
            </tr>
          </tbody>
        </table>
        <p>
          注意：视触不必承担高频闭环（handbook 强调其延迟/线缆/耗材/标定成本），但它非常适合在 Research Mode 里提供“几何真值”和“摩擦状态真值”。<br>
          对 Deploy Mode，teacher labels 只作为监督信号，不作为实时传感依赖。
        </p>

        <h4 id="student-policy-interface">7.2.3 Student → Policy 的接口规格（让部署可控、可验证）</h4>
        <p>
          为了让 A 真正可落地，必须把 student 的输出形式“写死”，并规定 policy 如何消费这些输出（否则会出现训练/部署语义不一致）。
        </p>
        <ul>
          <li><b>Student 输入</b>：对齐后的 Deploy 模态（RGB + q/qdot + current/effort + 可选 wrist_FT）</li>
          <li><b>Student 输出（推荐最小集合）</b>：</li>
        </ul>
        <ul>
          <li><code>contact_mode_logits</code>（3 类：stick/slip/roll）</li>
          <li><code>slip_risk</code>（0–1）</li>
          <li><code>failure_mode_logits</code>（多类）</li>
          <li><code>progress</code>（0–1）</li>
          <li><code>recoverability</code>（0–1）</li>
        </ul>
        <p>
          <b>Policy 使用约束（示例）</b>：
        </p>
        <ul>
          <li>若 <code>slip_risk</code> 高：优先触发“增大法向/调整接触几何/降速”类原语</li>
          <li>若 <code>failure_mode=jam</code> 且 <code>recoverability</code> 高：触发 backoff + reopen + re-approach</li>
          <li>若 <code>progress</code> 长时间停滞：切换原语（push→wedge→twist…）或触发重新定位</li>
        </ul>
        <p>
          这些规则也可以作为早期的 <b>rule-based policy</b>（阶段 1），随后逐步被 VLA policy 学到（阶段 2+）。
        </p>

        <h3 id="rm-qc">7.3 C：RM/QC flywheel（把部署数据变成“可用且可追责”的数据）</h3>
        <p>
          视触觉不必进 kHz 闭环，但可以显著提高数据质量与训练效率：QC、更准切段、更准 hard case 挖掘、更可控的恢复触发。
        </p>
        <ul>
          <li><b>QC</b>：Replay Validation（同一命令流重放能否重现成功）</li>
          <li><b>切段</b>：用 <code>progress</code>/<code>failure_mode</code> 进行 episode/subtask segmentation</li>
          <li><b>hard case</b>：用 <code>slip_risk</code>、接触模式变化、恢复触发点做 hard case mining</li>
          <li><b>恢复触发</b>：<code>recoverability</code> + <code>failure_mode</code> → 选择 recovery primitive（不要求视触觉进入 kHz）</li>
        </ul>

        <h4 id="replay-checklist">7.3.1 Replay Validation（最关键 QC）—可执行 checklist</h4>
        <p>目标：把“能不能训练”从主观判断变成硬指标。</p>
        <ul>
          <li><b>必须记录</b>：<code>cmd_joint_target</code>（命令流）与 <code>measured_q/measured_effort</code>（执行流），并带 <code>sync_status</code></li>
          <li><b>重放方式</b>：同一初始条件下重放命令流（或重放关键子段）</li>
          <li><b>判定指标</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>末端/关节轨迹误差（例如 \(\|q_{replay}-q_{ref}\|\) 的阈值）</li>
              <li>成败一致性（success label 一致）</li>
              <li>关键事件一致性（safety_trip/jam 事件是否一致）</li>
            </ul>
          </li>
          <li><b>产出</b>：写入 <code>replay_ok</code>（bool）与 <code>replay_score</code>（0–1，可选）</li>
        </ul>

        <h4 id="ac-mermaid">A+C 数据流（示意图）</h4>
        <pre><code>flowchart TD
  DeployMode[DeployMode_Data] --> Align[TimeSync_Align]
  ResearchMode[ResearchMode_Data_WithVisuoTactile] --> Align

  ResearchMode --> Teacher[TeacherLabeler_VisuoTactile]
  Teacher --> Labels[TeacherLabels]

  DeployMode --> Student[StudentEstimator_DeployOnly]
  Labels --> Student

  Student --> PolicyInputs[VLA_Policy_Inputs]
  DeployMode --> PolicyInputs

  PolicyInputs --> Policy[VLA_Policy]

  DeployMode --> RM[RM_QC_Flywheel]
  ResearchMode --> RM
  RM --> HardCases[HardCaseMining]
  HardCases --> Train[Retrain]
  Train --> Student
  Train --> Policy</code></pre>

        <h2 id="maintain">8) 标定、健康监测与可维护性</h2>
        <ul>
          <li><b>版本化标定资产</b>：<code>calib_version</code> / <code>calib_hash</code> 写进每条 episode metadata。</li>
          <li><b>触觉标定</b>：零点漂移、材料老化是常态；把 <code>recalib_required</code> 当作系统状态而不是人工备忘录。</li>
          <li><b>健康状态事件化</b>：用 <code>sensor_health</code>（drift/aging/dropout）驱动降额逻辑与维护节奏。</li>
        </ul>

        <h2 id="roadmap">9) 最小落地版与迭代路线图（走向超越人类）</h2>
        <h3 id="mvp">9.1 最小落地版本（你今天就能做出来）</h3>
        <ul>
          <li><b>硬件</b>：2 路 RGB（static + wrist）+ <code>effort/current</code> + <code>q/qdot</code>。</li>
          <li><b>软件</b>：统一时钟、对齐、Level-A 安全反射、Replay Validation。</li>
          <li><b>数据</b>：命令流 + 执行流 + episode metadata（sync/replay/calib）。</li>
        </ul>

        <h3 id="plan">9.2 迭代路线图</h3>
        <ul>
          <li><b>阶段 1（2–4 周）</b>：MVS + Replay Validation + 规则 RM。</li>
          <li><b>阶段 2（2–4 周）</b>：规则伪标签训练成轻量 RM（替换阈值）。</li>
          <li><b>阶段 3（1–2 月）</b>：加 2 个剪切/压力指尖，强化 Level-B 防滑。</li>
          <li><b>阶段 4（长期）</b>：加 1 个视触觉 + 1 个手腕 F/T，形成“因果判定 + 老师传感”。</li>
        </ul>

        <h2 id="refs">参考链接</h2>
        <ul>
          <li>
            多模态同步（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/multimodal_data_synchronization.md" target="_blank" rel="noopener noreferrer">multimodal_data_synchronization.md</a>
          </li>
          <li>
            触觉集成挑战（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/tactile_sensor_integration_challenges.md" target="_blank" rel="noopener noreferrer">tactile_sensor_integration_challenges.md</a>
          </li>
          <li>
            灵巧手采数（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/dexterous_hand_data_collection.md" target="_blank" rel="noopener noreferrer">dexterous_hand_data_collection.md</a>
          </li>
          <li>
            触觉传感器路线与工程取舍（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/product/sensors.md" target="_blank" rel="noopener noreferrer">product/sensors.md</a>
          </li>
        </ul>
      </div>

      <div id="footer" style="display:flex; justify-content:flex-start; align-items:center; gap: 1em; flex-wrap: wrap; padding: 2em 0;">
        <div>&copy; 2025 Sou Kit-Wa (Ken). All rights reserved.</div>
      </div>
    </div>

    <script>
      (function() {
        var savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') document.body.classList.add('dark-theme');
      })();
    </script>
  </body>
</html>

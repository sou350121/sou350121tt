<!DOCTYPE HTML>
<html>
  <head>
    <title>DexHand Sensing System Design - Sou Kit-Wa (Ken)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1000">

    <link rel="stylesheet" href="css/style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

    <style>
      .doc-header {
        padding-top: 6em;
        margin-bottom: 1.2em;
      }
      .page-title {
        font-size: 2.4em;
        line-height: 1.2em;
        font-weight: 600;
        margin-bottom: 0.4em;
      }
      .page-subtitle {
        color: #a0a8b0;
        line-height: 1.6em;
      }
      .back-link {
        display: inline-block;
        margin-top: 1.2em;
        margin-right: 0.8em;
        color: #146ebe;
        font-size: 1.05em;
      }
      .doc {
        margin-top: 2.0em;
        padding: 1.6em 1.8em;
        border-radius: 12px;
        border-left: 4px solid #146ebe;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      .doc h1, .doc h2, .doc h3, .doc h4, .doc h5 {
        color: #150c21;
        line-height: 1.35em;
        font-weight: 600;
      }
      .doc h1 {
        font-size: 2.0em;
        margin: 1.2em 0 0.6em 0;
      }
      .doc h2 {
        font-size: 1.55em;
        border-bottom: 2px solid rgba(20,110,190,0.25);
        padding-bottom: 0.35em;
        margin: 1.8em 0 0.8em 0;
      }
      .doc h3 {
        font-size: 1.25em;
        color: #146ebe;
        margin: 1.5em 0 0.6em 0;
      }
      .doc h4 {
        font-size: 1.1em;
        color: #1e5a8e;
        margin: 1.3em 0 0.5em 0;
      }
      .doc h5 {
        font-size: 1.0em;
        color: #2c5f7f;
        margin: 1.1em 0 0.5em 0;
        font-weight: 600;
      }
      .doc p, .doc li {
        color: #495057;
        line-height: 1.8;
        margin: 0.5em 0;
      }
      .doc p {
        margin: 0.8em 0;
      }
      .doc ul, .doc ol {
        margin: 0.8em 0 1.0em 1.8em;
      }
      .doc ul {
        list-style: disc;
      }
      .doc ol {
        list-style: decimal;
      }
      .doc li {
        margin: 0.4em 0;
      }
      .doc ul ul, .doc ol ul, .doc ul ol, .doc ol ol {
        margin-top: 0.4em;
        margin-bottom: 0.4em;
      }
      .doc code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.95em;
        background: rgba(15, 23, 42, 0.06);
        border: 1px solid rgba(15, 23, 42, 0.12);
        padding: 0.05em 0.35em;
        border-radius: 6px;
      }
      .doc pre {
        margin: 1.2em 0;
      }
      .doc pre code {
        display: block;
        padding: 1.2em 1.4em;
        overflow: auto;
        background: #0f1419;
        color: #e6edf3;
        border: 1px solid rgba(20, 110, 190, 0.35);
        border-radius: 10px;
        line-height: 1.6;
        font-size: 0.9em;
      }
      .doc blockquote {
        border-left: 4px solid rgba(20, 110, 190, 0.5);
        padding: 0.8em 1.2em;
        margin: 1.2em 0;
        background: rgba(20, 110, 190, 0.04);
        border-radius: 6px;
        color: #4b5563;
      }
      .doc blockquote p {
        margin: 0.4em 0;
      }
      .doc table {
        width: 100%;
        margin: 1.5em 0;
        border: 1px solid rgba(17, 24, 39, 0.12);
        border-radius: 10px;
        overflow: hidden;
        border-collapse: collapse;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      }
      .doc th, .doc td {
        padding: 0.85em 1.0em;
        border-bottom: 1px solid rgba(17, 24, 39, 0.10);
        vertical-align: top;
        text-align: left;
        line-height: 1.6;
      }
      .doc th {
        background: rgba(20, 110, 190, 0.08);
        font-weight: 700;
        font-size: 0.95em;
      }
      .doc tbody tr:hover {
        background: rgba(20, 110, 190, 0.03);
      }
      /* Primitives table: more readable and "doc-like" */
      .doc table.primitives-table {
        table-layout: fixed;
      }
      .doc table.primitives-table thead th {
        vertical-align: top;
        white-space: normal;
        line-height: 1.25;
      }
      .doc table.primitives-table .th-sub {
        display: block;
        margin-top: 0.25em;
        font-weight: 500;
        font-size: 0.88em;
        color: #6b7280;
      }
      .doc table.primitives-table tbody tr:nth-child(odd) {
        background: rgba(0, 0, 0, 0.015);
      }
      .doc table.primitives-table tbody tr:hover {
        background: rgba(20, 110, 190, 0.06);
      }
      .doc table.primitives-table td {
        word-break: break-word;
      }
      .doc table.primitives-table td:first-child,
      .doc table.primitives-table th:first-child {
        width: 10%;
      }
      .doc table.primitives-table td:first-child code {
        font-size: 0.95em;
        padding: 0.12em 0.55em;
        border-radius: 999px;
        border-color: rgba(20, 110, 190, 0.18);
        background: rgba(20, 110, 190, 0.10);
        white-space: nowrap;
      }
      .doc table.primitives-table code {
        white-space: nowrap;
      }
      .doc .toc {
        background: rgba(20,110,190,0.06);
        border: 1px solid rgba(20,110,190,0.18);
        border-radius: 10px;
        padding: 1em 1.2em;
      }

      body.dark-theme .doc {
        background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
        border-left-color: #4a9eff;
      }
      body.dark-theme .doc h1, body.dark-theme .doc h2, body.dark-theme .doc h3, body.dark-theme .doc h4, body.dark-theme .doc h5 {
        color: #ffffff;
      }
      body.dark-theme .doc h2 { border-bottom-color: rgba(74, 158, 255, 0.25); }
      body.dark-theme .doc h3 { color: #4a9eff; }
      body.dark-theme .doc h4 { color: #6ab0ff; }
      body.dark-theme .doc h5 { color: #85bcff; }
      body.dark-theme .doc p, body.dark-theme .doc li { color: #e2e8f0; }
      body.dark-theme .page-subtitle { color: #b0b0b0; }
      body.dark-theme .doc code {
        background: rgba(148,163,184,0.15);
        border-color: rgba(148,163,184,0.25);
        color: #e2e8f0;
      }
      body.dark-theme .doc blockquote {
        background: rgba(74, 158, 255, 0.08);
        border-left-color: rgba(74, 158, 255, 0.5);
        color: #cbd5e1;
      }
      body.dark-theme .doc table { border-color: rgba(148,163,184,0.18); }
      body.dark-theme .doc th { background: rgba(74, 158, 255, 0.12); }
      body.dark-theme .doc th, body.dark-theme .doc td { border-bottom-color: rgba(148,163,184,0.18); }
      body.dark-theme .doc tbody tr:hover { background: rgba(74, 158, 255, 0.08); }
      body.dark-theme .doc table.primitives-table tbody tr:nth-child(odd) {
        background: rgba(255, 255, 255, 0.03);
      }
      body.dark-theme .doc table.primitives-table tbody tr:hover {
        background: rgba(74, 158, 255, 0.10);
      }
      body.dark-theme .doc table.primitives-table .th-sub {
        color: #b0b0b0;
      }
      body.dark-theme .doc table.primitives-table td:first-child code {
        border-color: rgba(74, 158, 255, 0.30);
        background: rgba(74, 158, 255, 0.14);
        color: #d6ecff;
      }
      body.dark-theme .doc .toc {
        background: rgba(74,158,255,0.10);
        border-color: rgba(74,158,255,0.22);
      }
    </style>

    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body id="body">
    <div id="main">
      <div class="doc-header">
        <div class="page-title">DexHand Sensing System Design</div>
        <div class="page-subtitle">
          System design view: deployment × data × self-recovery.
        </div>
        <a class="back-link" href="index.html">&larr; Back to Home</a>
        <a class="back-link" href="blog.html">&larr; Back to Blog</a>
      </div>

      <div class="doc">
        <h1 id="dexhand-sensing-system">灵巧手 DexHand 的 Sensing System 设计（面向部署 × 采数 × 自恢复）</h1>
        <blockquote>
          <p>
            这是一份“可落地的系统设计文档”：从 <b>任务 → 力学因果 → 可观测信号 → 多频闭环 → 数据闭环（RM-in-loop）</b> 一次讲清楚，
            并给出从 MVS 到“超越人类能力”的迭代路线。
          </p>
        </blockquote>
        <p>
          <b>读者导览（面试/快速理解）</b>：先看 <a href="#multirate-table">2.1</a>（多频闭环与必需信号）→ <a href="#contact-system">2.2</a>（可观测性与 Teacher/Student 分工）→ <a href="#stack-decision">3.0</a>（决策逻辑与工程取舍）→ <a href="#teacher-student">7.2</a>（Teacher→Student 落地）→ <a href="#rm">6)</a>（RM-in-loop）。
        </p>

        <div class="toc">
          <h2 id="toc">目录（简版，减少分级）</h2>
          <p style="margin: 0.2em 0 0.8em 0;">
            读法建议：先把“为什么做（买家需求/目标）”讲清楚，再用 2.1 把“信号与闭环底座”锁死，最后讲 Teacher→Student + RM/critic 如何形成数据飞轮。
          </p>
          <ol>
            <li>
              <b>为什么做：需求与目标</b>
              <ul>
                <li><a href="#core">核心三问</a> / <a href="#buyer-demand">买家需求（VLA 为何需要 RM/critic）</a> / <a href="#kpi">KPI</a></li>
              </ul>
            </li>
            <li>
              <b>底座：信号 × 多频闭环（最难被替代）</b>
              <ul>
                <li><a href="#multirate-table">2.1 速查表（必需信号解释）</a> / <a href="#loops">Level‑A/B/C 职责边界</a></li>
              </ul>
            </li>
            <li>
              <b>传感栈：MVS → Pro（工程取舍与推荐布置）</b>
              <ul>
                <li><a href="#stack-decision">3.0 分层决策逻辑（why layering）</a> / <a href="#stack">布置与升级路径</a></li>
              </ul>
            </li>
            <li>
              <b>数据闭环：Teacher→Student + RM/critic（把失败变资产）</b>
              <ul>
                <li><a href="#teacher-student">7.2 Teacher→Student</a> / <a href="#rm">6) RM-in-loop</a> / <a href="#rm-qc">7.3 RM/QC flywheel</a></li>
              </ul>
            </li>
            <li>
              <b>工程化：可训练 / 可复现 / 可追责</b>
              <ul>
                <li><a href="#sync">时间同步与数据管线</a> / <a href="#data-collection-workflow">数据采集实施流程</a> / <a href="#maintain">标定与健康监测</a></li>
              </ul>
            </li>
            <li>
              <b>面试收束：落地顺序与结论</b>
              <ul>
                <li><a href="#roadmap">MVP 与迭代路线</a> / <a href="#feasibility">可行性与未来性</a> / <a href="#execution-plan">落地顺序</a> / <a href="#refs">参考链接</a></li>
              </ul>
            </li>
          </ol>
        </div>

        <h2 id="core">核心三问（直击要害）</h2>
        <p>
          在复杂环境和大量变量中，最容易跑偏的是“堆传感器/堆模型”。从第一性原理出发，DexHand 作为“物理因果接口”，系统必须随时回答三件事：
        </p>
        <ol>
          <li><b>接触发生了吗，接触在哪里？</b>（contact geometry：接触点/接触面/面积/法向）</li>
          <li><b>接触状态是否稳定，下一段时间会不会失败？</b>（contact_mode、slip_risk、jam_risk）</li>
          <li><b>如果要恢复，应切换到哪个物理原语？</b>（primitive / recoverability：backoff、regrasp、wedge、twist…）</li>
        </ol>
        <p>
          本文的 A（Teacher→Student）+ C（RM/QC flywheel）就是围绕这三问：Research Mode 用视触觉提供高信息真值，Deploy Mode 用可部署信号近似这些真值并形成闭环。
        </p>

        <h3 id="buyer-demand">买家视角：为什么 VLA 公司会“需要”RM/critic</h3>
        <p>
          DexHand 的核心客户是 VLA 公司/科研团队：他们买的不是“多几个传感器”，而是<strong>可持续迭代的能力</strong>——能把真实世界交互变成可训练、可复现、可评估的 dataset，并能进入 post-training/self-improvement 的飞轮。
          因此你必须把 RM/critic 做成“系统默认能力”（哪怕最初是规则版），否则手很容易被当成一次性采数工具，需求与复购都会弱。
        </p>
        <ul>
          <li><b>VLA 训练真痛点不是缺模型，而是缺“可用数据”</b>：多模态对齐、可回放、失败可解释；RM/critic 用于 QC、切段、hard-case 挖掘与数据加权。</li>
          <li><b>前沿公开路线也在用“复盘/critic”</b>：例如 π*0.6 的 Recap（post-training / Offline RL 复盘）、以及用 critic 提升长时程精细操作数据质量的路线（见 handbook 对照链接）。</li>
          <li><b>对 DexHand 的商业意义</b>：你交付的是“能进入客户训练闭环的数据底座”——可追责（replay）、可量化（SR/IR/ER + failure distribution）、可规模化（自动 triage），这比单点性能更难替代。</li>
        </ul>

        <h2 id="kpi">1) 系统目标与 KPI（把方向锁死）</h2>
        <p>
          DexHand 的 sensing system 不应追求“传感器越多越好”，而应追求 <b>长时稳定 + 可自救 + 数据可复现</b>（把交付与迭代能力做出来）。
        </p>
        <ul>
          <li><b>稳定 KPI</b>：连续运行 \(T\) 分钟内，<code>recover_event</code> 次数、<code>human_intervention</code> 次数、<code>drop</code> 次数。</li>
          <li><b>质量 KPI</b>：同一命令流重放（Replay）可复现率（同样的 command stream → 同样的 outcome）。</li>
          <li><b>效率 KPI</b>：单位时间可采集的“有效 episode”数量（排除不可复现/不可对齐的废数据）。</li>
          <li><b>安全 KPI</b>：过流/过温/软硬限位触发次数、近碰撞次数。</li>
          <li><b>VLA 对齐 KPI（建议加上）</b>：<code>intervention_rate</code>（单位时间/步的人工接管频率）、<code>executable_rate</code>（动作可执行率：IK/限位/自碰撞不过关的比例）。</li>
        </ul>
        <blockquote>
          <p>
            直觉：工程胜负手不是单次成功率，而是“长时稳定 + 快速自救 + 可复现数据飞轮”。
          </p>
        </blockquote>

        <h2 id="arch">2) 总体架构（传感栈 × 多频闭环 × 数据闭环）</h2>
        <p>三件事必须同时成立：</p>
        <ul>
          <li><b>传感栈分层</b>：高频低带宽信号兜底；少量高信息传感器负责“把接触讲清楚”。</li>
          <li><b>多频闭环分工</b>：kHz 止损、100–200Hz 防滑、5–15Hz 原语切换。</li>
          <li><b>数据闭环</b>：部署数据自动切段、打标签、挑 hard cases，再反哺训练（RM-in-loop）。</li>
        </ul>

        <h4 id="multirate-arch-diagram">2.0.1 多频闭环架构图</h4>
        <pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                            <b>多频分层闭环架构</b>                                    │
└─────────────────────────────────────────────────────────────────────────────────┘

  ╔═══════════════════════════════════════════════════════════════════════════╗
  ║  <b>Level-C: 语义策略层 (5–15Hz)</b>                                           ║
  ║  ┌─────────────────────────────────────────────────────────────────────┐  ║
  ║  │ 输入: RGB (static+wrist) + 任务状态 + wrist_FT 统计特征           │  ║
  ║  │ 处理: VLA Policy / 原语切换 (push/pull/twist/regrasp...)           │  ║
  ║  │ 输出: 子目标 + 原语参数 + Level-A/B 约束 (力限/速度限)            │  ║
  ║  └─────────────────────────────────────────────────────────────────────┘  ║
  ╚═══════════════════════════════════════════════════════════════════════════╝
                                     │
                        下发：primitive + params + constraints
                                     ↓
  ╔═══════════════════════════════════════════════════════════════════════════╗
  ║  <b>Level-B: 触觉协调层 (60–200Hz)</b>                                         ║
  ║  ┌─────────────────────────────────────────────────────────────────────┐  ║
  ║  │ <b>B1: 防滑/夹持</b>                     <b>B2: 精细力控 (Level-B-Force)</b>  │  ║
  ║  │ • 输入: current/effort + q/qdot    • 输入: wrist_FT (6D) + q/qdot  │  ║
  ║  │ • 控制: 夹持力调度、防滑响应       • 控制: 阻抗/导纳 (twist/insert)  │  ║
  ║  │ • 输出: 关节闭合量微调             • 输出: 末端 compliance 调整      │  ║
  ║  └─────────────────────────────────────────────────────────────────────┘  ║
  ╚═══════════════════════════════════════════════════════════════════════════╝
                                     │
                        微调：夹持力/姿态/接触几何
                                     ↓
  ╔═══════════════════════════════════════════════════════════════════════════╗
  ║  <b>Level-A: 安全反射层 (500–1000Hz)</b>                                       ║
  ║  ┌─────────────────────────────────────────────────────────────────────┐  ║
  ║  │ 输入: q/qdot + current/effort + 温度/限位/故障事件                 │  ║
  ║  │ 检测: stall (qdot≈0 且 current↑) / jam / 过流 / 越界              │  ║
  ║  │ 响应: 限流、力矩限幅、backoff (卸载/退避)                          │  ║
  ║  │ 输出: 关节力矩指令 (带安全限幅) → 执行器                          │  ║
  ║  └─────────────────────────────────────────────────────────────────────┘  ║
  ╚═══════════════════════════════════════════════════════════════════════════╝
                                     │
                                执行层 ↓
                      ┌────────────────────────────┐
                      │  执行器 (电机/驱动器)      │
                      │  → 物理世界 (接触/力/约束) │
                      └────────────────────────────┘

  ╔═══════════════════════════════════════════════════════════════════════════╗
  ║  <b>旁路：数据闭环 (RM-in-loop)</b>                                            ║
  ║  ┌─────────────────────────────────────────────────────────────────────┐  ║
  ║  │ 所有层数据 → timestamp 对齐 → episode 切段 → RM 打分/QC             │  ║
  ║  │          ↓                                                           │  ║
  ║  │  hard cases 挖掘 → Teacher labels → Student 训练 → 反哺 Policy      │  ║
  ║  └─────────────────────────────────────────────────────────────────────┘  ║
  ╚═══════════════════════════════════════════════════════════════════════════╝

<b>关键设计原则：</b>
  • 频率分层：高频兜底安全 (A)，中频稳定接触 (B)，低频策略决策 (C)
  • 信号分工：q/qdot + current/effort (必选底座) → wrist_FT (精细力控) → 视触觉 (teacher)
  • 延迟容忍：Level-A &lt;10ms，Level-B 10–30ms，Level-C &gt;50ms
  • 可降级：B2 失效 → 回退 B1；B 失效 → 只走简单任务 (MVS baseline)
</code></pre>

        <h3 id="multirate-table">2.1 多频闭环 × 传感信号：速查表</h3>
        <p>
          关键约束：视觉/视触觉的 30–120Hz 与编解码/处理延迟，无法直接承担 kHz 级闭环；因此必须分层（handbook 有详细同步与集成讨论）。
        </p>
        <p>
          <b>符号速释（这一节里常用的信号是什么意思）</b>：
          <code>q</code> = 关节位置（角度/位移），<code>qdot</code> = 关节速度（\(\dot q\)）；
          <code>effort</code> = 关节力矩/驱动器输出的“用力”（有些系统直接给力矩，有些是估算值）；
          <code>current</code> = 电机电流（常作为力矩/负载的 proxy）；
          <code>rgb_static</code>/<code>rgb_wrist</code> = 外部相机/腕部相机画面；
          <code>wrist_FT</code> = 手腕六维力/力矩（F/T）；
          “限位/故障事件” = 软硬限位触发、过流/过温保护、驱动器 fault、急停等离散事件（必须可回放）。
        </p>
        <table>
          <thead>
            <tr>
              <th>层级</th>
              <th>频率</th>
              <th>核心职责</th>
              <th>必需信号（建议）</th>
              <th>可选增强</th>
              <th>延迟容忍</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Level-A</b></td>
              <td>500–1000Hz</td>
              <td>安全反射/止损（限流、卡死检测、退避）</td>
              <td><code>q/qdot</code>, <code>current/effort</code>, 温度/限位/故障事件</td>
              <td>硬件触发/更高频总线（EtherCAT 等）</td>
              <td>极低（&lt;10ms）</td>
            </tr>
            <tr>
              <td><b>Level-B</b></td>
              <td>60–200Hz</td>
              <td>接触协调/防滑（夹持力调度、微调几何）<br><b>精细力控（twist/insertion/pry）</b></td>
              <td><code>current/effort</code>（触觉代理）, <code>q/qdot</code><br><b>对精细力控：<code>wrist_FT</code>（6D，必选）</b></td>
              <td>指尖剪切/压力阵列；耐久触觉（ITPU/霍尔/类 uSkin）</td>
              <td>中等（10–30ms）</td>
            </tr>
            <tr>
              <td><b>Level-C</b></td>
              <td>5–15Hz</td>
              <td>语义策略/原语切换（push/pull/wedge/twist…）</td>
              <td><code>rgb_static</code>, <code>rgb_wrist</code>, 任务状态</td>
              <td>视触觉特征（几何/接触模式）作为 teacher 信号</td>
              <td>高（&gt;50ms）</td>
            </tr>
          </tbody>
        </table>

        <h4 id="multirate-required-signals">2.1.1 “必需信号（建议）”逐项解释（为什么缺了就会翻车）</h4>
        <p>
          这里的“必需”指的是：<b>它们构成每一层闭环的最小可观测因果集合</b>——能止损、能自恢复、能回放追责。
          不是说没有其它传感就做不了研究，而是说没有这些信号，你就很难把系统做成“可交付”的长期稳定系统。
        </p>
        <ul>
          <li>
            <b>Level-A（500–1000Hz）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>
                <b><code>q/qdot</code></b>：用于检测 <b>stall/jam</b>（<code>qdot≈0</code>）、越界趋势（逼近软硬限位）、以及“退避是否真的在动”。
                缺它会导致：你只能看到电流大，但无法区分“正常高负载”与“卡死/顶住”，恢复动作也无法验证是否生效。
              </li>
              <li>
                <b>术语澄清：stall vs jam（都是什么、差在哪）</b>：
                <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
                  <li>
                    <b>stall（停转/堵转）</b>：<b>从电机/驱动视角</b>看“命令在推，但轴/关节几乎不动”。典型特征是 <code>|qdot|</code> 很小，同时 <code>current/effort</code> 持续偏高（或快速上升）。
                    它可能是“暂时的”（例如短暂碰到障碍/静摩擦峰值）。
                  </li>
                  <li>
                    <b>jam（卡死/卡滞）</b>：<b>从机构/接触视角</b>看“被几何约束锁住/楔住/顶死”，导致运动无法继续或极难继续。
                    jam 往往伴随：<code>stall</code> + 事件持续时间更长 + 反复发生/需要退避才解除，且经常与 <code>misalignment</code> 或外部约束有关。
                  </li>
                  <li>
                    <b>为什么要分清</b>：Level‑A 要做的是“止损与保护”，所以更关心 <b>stall 是否进入危险窗口</b>（过流/过热/结构受力）；
                    Level‑C/恢复逻辑更关心 <b>jam 的物理原因与解锁路径</b>（backoff、reopen、re-approach、换原语）。
                  </li>
                  <li>
                    <b>可执行的最小判定（示例）</b>：在窗口 \(\Delta t\) 内若 <code>|qdot| &lt; v_{min}</code> 且 <code>current/effort &gt; \tau_{min}</code> → 标记 <code>stall</code>；
                    若 <code>stall_time_ms</code> 超过阈值或退避后重复出现 → 升级为 <code>jam_state</code> 并触发更强的恢复原语/人工介入。
                  </li>
                </ul>
              </li>
              <li>
                <b><code>current/effort</code></b>：止损的第一响应（限流/扭矩限幅）、摩擦/碰撞/过载的最直接 proxy。
                缺它会导致：止损只能靠低频视觉或高层判断，等你“看到”时往往已经损坏。
              </li>
              <li>
                <b>温度/限位/故障事件</b>：长期交付必须把“保护触发”事件化（<code>safety_trip</code>）并写入回放，否则你无法追责“是策略错还是驱动保护触发”。
              </li>
            </ul>
          </li>
          <li>
            <b>Level-B（60–200Hz）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>
                <b><code>current/effort</code>（触觉代理）</b>：在没有高频触觉阵列的情况下，它是"接触状态变化"的最低配观测（夹持变强/变弱、阻力突变、微滑动引发的扰动）。
                缺它会导致：你只能靠视觉判断接触稳定，而视觉对 slip/misalignment 往往滞后且不可用（遮挡/光照）。
              </li>
              <li>
                <b><code>q/qdot</code></b>：把 effort/current 的变化解释成"接触导致"还是"主动运动导致"（同样的电流变化，在不同 <code>qdot</code> 下物理意义不同）。
                缺它会导致：防滑与夹持调度会变成误触发（把主动加速当滑移，把静止摩擦当卡死）。
              </li>
              <li>
                <b><code>wrist_FT</code>（6D F/T）对精细力控的必要性</b>：对 twist/insertion/pry 等精细力控任务，<code>current/effort</code> 只是力矩的弱 proxy（受齿隙、摩擦、传动比影响），<strong>无法提供扭矩闭环（τz）或侧向力/力矩的精确反馈</strong>。
                缺它会导致：擰瓶盖时无法区分"扭矩达标"与"手指打滑"；peg-in-hole 无法区分"顶住"与"对歪"；脆弱物抓取时电机摩擦吃掉精度。<br>
                <b>结论：对精细力控任务，wrist_FT 是必选而非可选。</b>
              </li>
            </ul>
          </li>
          <li>
            <b>Level-C（5–15Hz）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>
                <b><code>rgb_static</code></b>：提供全局上下文（目标/障碍/可行 approach），决定“进入接触前”的策略。
                缺它会导致：策略只能局部贪心，容易在复杂场景里反复试错、效率差。
              </li>
              <li>
                <b><code>rgb_wrist</code></b>：提供近场视角（遮挡更少、接触瞬间可见），对“对齐/重新接近（re-approach）”非常关键。
                缺它会导致：对齐主要靠猜，misalignment 变多，恢复路径成本上升。
              </li>
              <li>
                <b>任务状态</b>：至少要有子任务/原语阶段（例如 <code>primitive</code>、<code>subtask</code>、<code>target_state</code>），否则你无法把同一段数据切成可训练的 episode，也无法评估 progress。
              </li>
              <li>
                <b>视触觉在哪里？</b>：视触觉通常 <b>不作为 Level-C 的“必需输入”</b>，而是作为 <b>Research Mode 的 teacher/诊断信号</b>——在接触发生后提供 <code>contact_patch</code> / <code>contact_mode</code> / <code>slip_risk</code> 等高信息真值，
                再通过 <b>Teacher→Student</b> 蒸馏为部署可用的低维状态供 policy 使用。<br>
                换句话说：Level‑C 必需的是“看得见场景并知道自己在做什么”（RGB + task state）；视触觉负责“把接触讲清楚”（teacher labels + 复盘），不和 5–15Hz 的策略层抢主入口。
              </li>
            </ul>
          </li>
        </ul>

        <h4 id="multirate-principles">2.1.2 设计原则（压缩成 5 条）</h4>
        <ul>
          <li><b>P1 Timestamp-at-source</b>：各模态在产生瞬间打统一时钟戳（PTP 优先）。</li>
          <li><b>P2 多频闭环</b>：不要用 30Hz 视觉硬扛 kHz 接触稳定；必须分层。</li>
          <li><b>P3 接触可观测</b>：仅 RGB 很难判断“滑 / 夹歪”；至少要有 <code>current/effort</code> 作为触觉代理。</li>
          <li><b>P4 可维护优先</b>：触觉（尤其视触觉）是易损件；维护成本会直接反噬 uptime。</li>
          <li><b>P5 先跑 MVS</b>：先做到“可复现采数 + 自恢复”，再升级传感器，而不是一开始堆满硬件。</li>
        </ul>

        <h3 id="contact-system">2.2 深度梳理：接触系统的状态空间 × 可观测性（为什么必须 Teacher/Student 分工）</h3>
        <p>
          灵巧操作的难点不在“动作学得不够像”，而在于<strong>接触是一类强非线性、强历史依赖、部分不可观测</strong>的系统：
          同样的 <code>current/effort</code> 扰动可能来自不同的接触几何；同样的视触形变也可能因为材料状态变化而不同。
          因此一个可交付的系统必须把“要学什么”定义成<b>可对齐、可回放、可验收的因果状态</b>，而不是把传感器当作目标。
        </p>
        <ul>
          <li>
            <b>因果状态（policy 真正需要的最小集合）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li><b>几何类</b>：是否接触、接触 patch（面积/位置/主方向）、相对偏置（misalignment）。</li>
              <li><b>力学类</b>：法向预算与切向负载（等价于摩擦边界 \(\|f_t\|\le \mu f_n\) 的余量）、外部约束反力（push/pull/twist/pry）。</li>
              <li><b>摩擦/失效类</b>：<code>contact_mode</code>（stick/slip/roll）、<code>slip_risk</code>、<code>jam_state</code>、<code>recoverability</code>。</li>
            </ul>
          </li>
          <li>
            <b>为什么 Deploy 侧不追“几何真值”</b>：在复杂接触下，几何往往不可由低维本体信号唯一反演（ill-posed）；
            但 slip/jam/过载这类<strong>失效事件与风险</strong>在 <code>q/qdot</code> 与 <code>current/effort</code> 上具有更稳定的一致签名，适合做闭环止损与恢复。
          </li>
          <li>
            <b>为什么视触适合当 teacher</b>：视触能提供高信息的几何/接触模式真值，但它的观测会被材料与环境扰动：
            \[
              y_{vt} = f(x_{contact},\, m_{gel},\, T,\, age,\, contam)
            \]
            其中 \(m_{gel}\)（批次/模量）、\(T\)（温度）、age（老化）、contam（污染/润滑）都会改变“同一个接触”的表观形变。
            所以视触应承担“真值通路”（Research/Teacher），并用版本化 + 置信度把不确定性显式化（见 7.2.2 与 8)）。
          </li>
          <li>
            <b>补充：有遮光层/保护层/AR 仍会被“环境”扰动</b>：遮光与 AR 主要解决“外部环境光入射/反射”这一类光学干扰，但<strong>环境扰动并不只等于外界光</strong>。<br>
            视触的观测链路包含「接触 → 胶体形变（材料力学）→ 内部成像（照明/镜头/传感器）」，因此温度会改变胶体模量与粘性（形变幅度/滞回/恢复时间），
            污染/润滑会改变摩擦边界条件（接触物理状态本身就变了）与表面散射特性（对比度/高光），老化/批次差异会改变材料与贴合状态。<br>
            结论：遮光能显著提升稳定性，但仍需要 <code>gel_id</code>/<code>temp_gel</code>/<code>teacher_version</code>/<code>teacher_uncertainty</code> 来把这些扰动显式化与可追责。
          </li>
          <li>
            <b>Teacher→Student 的真实含义</b>：蒸馏的不是“视触图像”，而是把 teacher 的高信息真值压缩成部署可用状态；
            让 student 在 Deploy 信号里学到与这些状态对应的动力学签名与风险边界，从而把研究上限转化为交付稳定性。
          </li>
        </ul>
        <blockquote>
          <p><b>落地检查</b>：如果你能用 Deploy 信号稳定输出 <code>slip_risk</code>/<code>jam_state</code>/<code>recoverability</code>，并驱动 recover primitives 提升 KPI，那么这套分工就是“能跑”的；几何真值则留给 teacher 去提供与校准。</p>
        </blockquote>

        <h3 id="vla-fit">2.3 面向前沿 VLA：动作表示 × 推理延迟 × 分层接口（让模型“聪明且不手笨”）</h3>
        <p>
          VLA 前沿（RT/Octo/OpenVLA/π0/π* 等）在“动作生成”上分成三类：<b>离散 Token</b>、<b>Diffusion</b>、<b>Flow Matching</b>。
          它们共同的现实约束是：即便模型再强，<b>直接以 VLA 在 kHz 级输出电机命令</b>仍然不经济也不可靠（推理延迟、噪声、动作抖动、误差累积都会被物理世界放大）。
          因此本方案把 VLA 放在 <b>Level‑C（5–15Hz）</b> 的“原语/子任务接口”上，把高频稳定性交给 Level‑A/B 的闭环去兜底。
        </p>
        <ul>
          <li><b>为什么要分层</b>：Tokenization 可能引入量化误差与高频 bin 抖动；Diffusion 迭代步多、推理慢；Flow 更快但仍更适合 5–50Hz 的连续动作生成而非 kHz 伺服。</li>
          <li><b>推荐的 VLA Action Space（更契合灵巧手）</b>：让 VLA 输出 <b>primitive + 参数</b>（例如 <code>press</code>/<code>pull</code>/<code>twist</code>/<code>regrasp</code> + 目标方向/上限/速度/容忍度），再由 Level‑A/B 把它落到电机级闭环。</li>
          <li><b>触觉在 VLA 里的角色（前沿共识）</b>：视觉负责全局几何与语义，触觉负责“接触相位的真反馈”。因此 Deploy 侧必须能输出 <code>contact_mode</code>/<code>slip_risk</code>/<code>recoverability</code> 这类低维触觉状态；Research/Teacher 侧用多点视触（pad+side）把接触真值讲清楚，再蒸馏给 student。</li>
        </ul>
        <blockquote>
          <p><b>一句话</b>：VLA 负责“做什么/怎么做”（原语与策略），A/B 负责“做得稳不稳”（接触闭环与止损）。这也是为什么本方案对 Token/Diffusion/Flow 都兼容——你只要把它们接到同一个原语接口上。</p>
        </blockquote>

        <h2 id="stack">3) 传感栈分层（MVS → Pro）与推荐布置</h2>
        <p>
          这一节要解决的不是“买什么传感器”，而是：在复杂环境里，用最少的、不容易坏的信号去回答前文的<b>核心三问</b>。
          记住一个思维框架：<b>先保证可观测因果（observability），再追求更高分辨率</b>。
        </p>

        <h3 id="stack-decision">3.0 决策逻辑（为什么这样分层）</h3>
        <ul>
          <li><b>你永远需要的底座</b>：<code>q/qdot</code> + <code>current/effort</code>（高频、便宜、稳定、可回放）</li>
          <li><b>你最容易失明的因果</b>：滑移（slip）、卡死（jam）、几何偏置（misalignment）</li>
          <li><b>因此要把“信息”分两类</b>：</li>
        </ul>
        <ul>
          <li><b>闭环信息（要快）</b>：Level-A/Level-B 需要 60–1000Hz、低延迟、可长期运行 → 优先用 proprio + effort/current +（可选）wrist F/T 或耐久触觉阵列</li>
          <li><b>老师信息（要准）</b>：Research Mode 用视触觉给几何/接触模式真值 → 通过 A（Teacher→Student）蒸馏到部署可用的状态</li>
        </ul>

        <h4 id="stack-feasibility">可行性论证（为什么这套分层“真的能跑”）</h4>
        <p>
          这套分层成立的第一性原因是：<b>闭环控制需要的是“可长期、低延迟、可回放的因果信号”，而不是“看见一切几何细节”</b>。
          在长时部署里，视触觉（凝胶/表皮/光学）很难满足 uptime 与维护成本约束，因此它更适合承担“老师信息”（生成近真值标签），而不是承担“闭环主力”。
        </p>
        <p>
          你最容易失明的三类因果（slip / jam / misalignment）本质更接近<b>事件检测 + 模式切换 + 风险评估</b>问题：
          <code>q/qdot</code> 与 <code>current/effort</code> 能提供强一致的“动力学扰动证据”（可回放、可追责），再叠加（可选）<code>wrist_FT</code> 或耐久触觉阵列，就能把“止损与恢复”做得足够可靠。
          研究模式下再用视触觉给出接触几何/接触模式真值，通过 Teacher→Student 蒸馏为部署可用的状态（如 <code>slip_risk</code>、<code>jam_state</code>、<code>misalign_class</code>、<code>contact_mode</code>），从而实现<b>研究上限</b>与<b>部署稳定</b>的同时满足。
        </p>
        <p>
          <b>RM-in-loop 的关键作用</b>不是“给一个总分”，而是把连续流变成可用数据：
          自动切段、挑 hard cases、触发复核/重采样，保证 teacher 标签与部署失败代价函数对齐，避免数据飞轮被噪声带偏。
        </p>

        <h4 id="stack-conditions">成立条件清单（不满足就会翻车）</h4>
        <ul>
          <li><b>时间与回放</b>：所有关键通道必须 <b>timestamp-at-source</b>，并且可对齐回放；否则 slip/jam 的因果会被“不同步”学错。</li>
          <li><b>闭环职责边界</b>：Level-A/B 只负责“止损与恢复”（安全/防滑/解卡/退避），不承担高分辨几何重建；高分辨几何只用于 teacher。</li>
          <li><b>可部署状态定义</b>：Teacher 输出必须被压缩成部署可用、可验收的低维状态（事件/模式/风险/余量），而不是把毫米级几何硬塞进部署回路。</li>
          <li><b>恢复动作空间</b>：必须有明确的 recover primitives（如 <code>backoff</code>/<code>regrasp</code>/<code>re-approach</code> 等），并把触发条件写成规则或可学习门控；只检测不恢复等于不可用。</li>
          <li><b>域移管理</b>：Research 视触装配不能显著改变控制与摩擦边界；或训练时显式做分布对齐/随机化，否则 Teacher→Student 会学到“研究特有”的伪特征。</li>
          <li><b>传感健康是一等公民</b>：<code>sensor_health</code>/<code>calib_version</code>/<code>recalib_required</code> 必须进数据与策略输入；长期部署里“传感器退化”是常态，不建模就会默默劣化。</li>
          <li><b>验收指标绑定失败代价</b>：以误报/漏报、恢复成功率、平均止损时间、任务成功率等硬指标为准；RM 只做 triage（排序/筛选），不能替代验收。</li>
        </ul>

        <h4 id="stack-failure-mitigations">失败模式与对策（工程上最常见的坑）</h4>
        <table>
          <thead>
            <tr>
              <th>失败模式</th>
              <th>典型现象</th>
              <th>根因</th>
              <th>怎么发现（可观测信号）</th>
              <th>对策（可落地）</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Teacher/Student 标签不一致</td>
              <td>学生模型学不稳、上线后误报/漏报高</td>
              <td>标签定义不工程化（人/场景之间不一致）</td>
              <td>同一片段不同版本 teacher 输出差异大；RM 复核分歧段</td>
              <td>把标签写成“阈值 + 时间窗 + 版本号”；RM 专门挖“分歧段”做复标</td>
            </tr>
            <tr>
              <td>Research→Deploy 域移</td>
              <td>研究效果好、部署崩盘</td>
              <td>视触装配改变动力学/摩擦；或训练分布偏置</td>
              <td>部署数据上的状态分布漂移（统计特征/失败类型变了）</td>
              <td>老师只做标注不改控制边界；训练做随机化/对齐；部署端以 proprio/effort 为主</td>
            </tr>
            <tr>
              <td>多模态不同步导致“学错因果”</td>
              <td>slip/jam 预测提前/滞后，触发恢复无效</td>
              <td>相机/触觉/本体时间戳不一致，alignment 漂</td>
              <td>回放对齐后事件峰值错位；同一事件跨源延迟不稳定</td>
              <td>timestamp-at-source + 对齐校准；事件标签用窗口而不是单帧点</td>
            </tr>
            <tr>
              <td>闭环过度依赖“老师传感”</td>
              <td>视触坏了/脏了就失明</td>
              <td>把高信息但不耐久的信号当主闭环输入</td>
              <td>一旦遮挡/污染，性能断崖式下降</td>
              <td>老师信号只用于训练/标注；部署闭环只依赖可长期信号，并有健康降级路径</td>
            </tr>
            <tr>
              <td>RM 指标带偏数据飞轮</td>
              <td>数据越采越“好看但没用”</td>
              <td>RM 学到了表象特征，未对齐失败代价函数</td>
              <td>RM 高分片段并不提升部署 KPI；hard cases 被遗漏</td>
              <td>RM 只做 triage；用部署 KPI 做闭环；定期插入挑战集做校准</td>
            </tr>
            <tr>
              <td>传感器漂移/退化未建模</td>
              <td>慢性劣化、很久才被发现</td>
              <td>触觉耗材化、标定变化、线缆接触不良</td>
              <td><code>sensor_health</code> 统计漂移；失败率随时间上升</td>
              <td>把健康/标定版本写进数据；策略对健康做门控与降级；定期自动自检</td>
            </tr>
          </tbody>
        </table>

        <h3 id="sensor-capability">3.0.1 传感配置 vs 可解锁的任务能力（速查表）</h3>
        <p>
          不同的传感配置决定了系统能够完成的任务谱系。下表明确展示：<b>每增加一个传感器，能解锁什么新能力</b>。
        </p>
        <table>
          <thead>
            <tr>
              <th>配置等级</th>
              <th>传感器组合</th>
              <th>可做的任务</th>
              <th>不能做的任务（缺什么）</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>MVS<br>（阶段 1–2）</b></td>
              <td>RGB (static+wrist) + proprio (q/qdot) + <code>current/effort</code></td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li>简单抓取、pick-and-place</li>
                  <li><code>press</code>（粗力控）、<code>push</code></li>
                  <li>基于 effort 的粗防滑</li>
                  <li><code>backoff</code>、<code>reopen</code>、<code>regrasp</code></li>
                </ul>
              </td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li><b>精细力控</b>：twist、insertion、pry（缺扭矩/侧向力精确闭环）</li>
                  <li>毫牛级夹持、脆弱物（电机摩擦吃掉精度）</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td><b>+wrist_FT<br>（阶段 2.5）</b></td>
              <td>上述 + <b>6D F/T（≥200Hz）</b></td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li><b>新增</b>：<code>twist</code>（擰瓶盖）、<code>insertion</code>（精密插入）、<code>pry</code>（撬开）</li>
                  <li><code>pull</code> 拉力闭环、<code>wedge</code> 力矩限幅</li>
                  <li>推/拉/扭的因果判定（外部约束反力）</li>
                </ul>
              </td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li>毫牛级夹持精度（指尖直接测力更优）</li>
                  <li>高品质 slip detection（指尖触觉更敏感）</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td><b>+指尖力<br>（阶段 3）</b></td>
              <td>上述 + <b>指尖 3 轴力传感器 ×2</b></td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li><b>新增</b>：脆弱物抓取（毫牛级法向控制）</li>
                  <li>精细防滑（直接测量指尖摩擦状态）</li>
                  <li>夹持力精确闭环（不受传动摩擦影响）</li>
                </ul>
              </td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li>接触几何真值（面积/边缘/微滑动）</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td><b>+视触觉<br>（阶段 4）</b></td>
              <td>上述 + <b>多点视触（pad+side）</b><br>+ 可选：温度传感器 ×1–2</td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li><b>新增</b>：高品质 teacher labels（接触几何/接触模式/力学真值）</li>
                  <li>显著提升 RM/QC 质量（hard case 挖掘更准确）</li>
                  <li>Teacher→Student 蒸馏质量提升</li>
                  <li><b>（温度可选）</b>材质识别 (metal/plastic/wood/fabric)、热安全检测</li>
                </ul>
              </td>
              <td>—（核心能力完整；场景特定可继续扩展）</td>
            </tr>
          </tbody>
        </table>
        <blockquote>
          <p>
            <b>关键洞察</b>：wrist_FT 是解锁精细力控的"最小投入"（单传感器），但它不替代指尖触觉的防滑与精细夹持能力；
            视触觉是 teacher 信息的"金标准"，但它更适合用于 Research Mode 而非闭环主力。
          </p>
        </blockquote>

        <h3 id="mvs">3.1 Level-0（MVS：最小可行传感）</h3>
        <p>目标：低成本获得“接触判别能力 + 可复现数据”。</p>
        <ul>
          <li><b>视觉</b>：<code>rgb_static</code> + <code>rgb_wrist</code>（强烈建议腕相机）。</li>
          <li><b>本体</b>：<code>q</code>、<code>qdot</code>。</li>
          <li><b>触觉代理（必选其一）</b>：<code>motor_current</code> / <code>joint_effort</code>。</li>
          <li><b>事件信号（软件生成）</b>：<code>contact_flag</code>、<code>safety_trip</code>。</li>
        </ul>
        <p>
          这套配置已经能支撑：卡死/顶住检测、粗粒度夹持强弱闭环、Replay Validation（决定数据能不能用于训练）。
        </p>
        <p>
          <b>这背后的要害</b>：即便你“看不见接触几何”，你也要能用 <code>current/effort</code> 判断“有没有接触/有没有卡死/夹持是否在变强”。<br>
          否则部署数据会变成不可回放、不可追责的噪声。
        </p>

        <h3 id="tactile">3.2 Level-1（触觉层：让“滑移 / 接触几何”可观测）</h3>
        <p>
          这一层的目标是把两类关键信息补齐：<br>
          (1) <b>滑移/摩擦状态</b>（用于 Level-B 的防滑闭环）；<br>
          (2) <b>接触几何真值</b>（用于 Research Mode 的 teacher labels）。<br>
          为了兼顾 uptime 与信息量，部署侧推荐空间布置：<b>“2 + 1 + 1”</b>；Research（teacher）侧则建议在关键受力面追加“多点视触”（尤其侧边），以覆盖手套材料在外力变化下的侧向形变。
        </p>
        <ul>
          <li><b>2 个指尖高频剪切/压力阵列（100–200Hz）</b>：拇指 + 食指（防滑闭环主力）。</li>
          <li><b>1 个指尖高信息几何（视触觉 30–60Hz）</b>：拇指或食指（指腹接触点/面积/边缘/微滑动）。<b>Research 可追加：同指的侧边/侧壁视触</b>（捕捉侧向形变与剪切/扭转模式）。</li>
          <li><b>1 个手腕 6D F/T（≥200Hz）</b>：推/拉/扭/撬的因果判定（外部力矩 / 约束反力）。</li>
        </ul>
        <p>
          为什么不是“全指视触觉”：全铺会把带宽、布线、耐久、标定维护成本拉爆；
          “少量高信息老师 + 少量高频工兵 + 本体信号兜底”更接近工程最优解。
        </p>

        <h4 id="visuotactile-materials-front">视触的材料物理学（提前说明：为什么它更适合当 teacher）</h4>
        <p>
          视触（gel-based）把“接触边界条件”映射为可观测的形变/光学纹理，这正是它能给出高信息几何/接触模式真值的原因。
          但这条映射<strong>强依赖材料状态</strong>：粘弹性/滞回、蠕变、温度、老化、污染会让同一个接触在不同时间/不同胶体批次下呈现不同“表观形变”。
          因此工程上最稳的用法是：<b>把视触当 Research Mode 的 teacher（提供近真值与诊断），而不是把它当 Deploy Mode 的闭环主力</b>。
        </p>
        <ul>
          <li><b>粘弹性/滞回</b>：同样压入深度，上升段/下降段响应不同 → teacher label 更应基于时间窗特征与变化率，而非单帧阈值。</li>
          <li><b>蠕变/应力松弛</b>：持续接触时形变会随时间漂移 → <code>contact_confidence</code>/<code>slip_risk</code> 需要显式窗口 \(\Delta t\)。</li>
          <li><b>温度/老化/污染</b>：模量与光学特征漂移 → 必须把 gel 视为耗材，并把“材料状态”写进 metadata（见 8)）。</li>
        </ul>
        <p>
          <b>温度梯度是常态（一个直观类比）</b>：人体也不是“全身同温”——核心温度通常稳定在 36.5–37.5℃，而室温 20–25℃ 下皮肤表面温度常见在 32–35℃，
          两者温差常在 1–5℃（环境极端时可更大）。同样地，机器人手的“内部/驱动温度”与“指尖胶体表面温度”通常也会有差异。<br>
          因此工程上不能用“机体温度”替代 <code>temp_gel</code>：要把胶体温度当作 teacher 侧的关键解释变量与校准条件。
        </p>
        <blockquote>
          <p><b>一句话</b>：视触提供高信息“真值”，但真值受材料影响；所以 teacher 必须版本化 + 输出置信度，student 必须学“物理因果”而不是“胶的纹理”。</p>
        </blockquote>

        <h4 id="teacher-multipoint-vt">Teacher：为什么需要“更多位置的视触”（指腹 + 侧边）来仿手套</h4>
        <p>
          你提到的关键点很重要：当外力方向变化（推/拉/扭/侧向摩擦）时，手套/电皮肤这种“包覆材料”会在<b>侧边</b>产生明显形变（鼓起、折皱、接触面积迁移），
          而这些形变对电传感（电容/电阻阵列）的读数影响很大。若 teacher 只看指腹一个视触面，student 很容易学到“指腹局部视角下的伪规律”，在侧向受力/边缘接触时失效。
        </p>
        <ul>
          <li><b>建议的 teacher 视触布置（Research Mode）</b>：至少覆盖拇指/食指的 <b>指腹（pad）</b> + <b>侧边（sidewall/侧面受力面）</b>；对经常做扭转/撬动的任务，再加一个“指尖边缘/角点”视触面。</li>
          <li><b>teacher 要产出的额外信息</b>：除 <code>contact_patch</code> 外，再加 <code>contact_patch_stats</code>（面积/质心/主方向）与“侧边形变特征”（可先用规则：侧边 patch 面积/位移能量），用于监督 student 学到更稳的接触模式与风险。</li>
          <li><b>落地注意</b>：多点视触会引入更多材料/温度/老化变量，因此更需要 <code>gel_id</code>/<code>temp_gel</code>/<code>teacher_version</code>/<code>teacher_uncertainty</code> 做版本化与降权训练。</li>
        </ul>

        <h4 id="placement-heuristic">布置启发式（在复杂环境里如何选“装哪里”）</h4>
        <ul>
          <li><b>先给拇指/食指</b>：它们承担最多的主动接触与相对运动（也是 slip/jam 最频发的位置）</li>
          <li><b>视触觉只当老师，不当闭环主力</b>：它输出几何/接触模式真值，用于 teacher labels；闭环仍依赖高频信号</li>
          <li><b>手腕 F/T 的价值</b>：当任务是 push/pull/twist/pry 这类“力学原语”，F/T 让因果可观测（否则只剩 current/effort 的弱 proxy）</li>
        </ul>

        <h4 id="normal-force-proxy">补充：法向力 proxy 与“压力传感”不要想当然</h4>
        <p>
          这里容易踩一个物理直觉坑：多数视触结构是 <b>实体软胶 + 刚性背板（例如亚克力）</b>，它测的是形变/光学纹理，<b>并不存在“腔体气压随按压变化”这一默认信号</b>。<br>
          只有当你<strong>专门设计</strong>了密封腔体/气囊/微流体通道时，“压力传感”才成立，并且它更接近<b>低维法向力 proxy + 健康/漏气监测</b>，依旧不能替代视触的几何真值。
        </p>
        <p>
          因此在本方案里：法向/接触的最低配仍以 <code>current/effort</code>、（可选）<code>wrist_FT</code>、以及耐久触觉阵列为主；视触负责 teacher labels（几何/接触模式），而不是依赖"气压"做闭环。
        </p>

        <h4 id="thermal-sensing">3.2.1 温度感知：材质识别 × 安全检测（可选增强）</h4>
        <p>
          温度感知通过<b>热导率差异</b>可以区分材质（金属 vs 塑料 vs 织物），并提供安全检测（过热预警）。
          但它的<b>时间常数慢</b>（0.5–5秒 vs 力学的 1–10毫秒），<strong>无法参与 Level-A/B 的高频闭环</strong>，只能作为 Level-C 的语义输入。
        </p>

        <h5>温度感知的价值与局限</h5>
        <table>
          <thead>
            <tr>
              <th>维度</th>
              <th>价值</th>
              <th>局限</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>材质识别</b></td>
              <td>
                通过接触瞬间的温度变化率 (dT/dt) 估计热导率：<br>
                • 金属 (50–200 W/m·K) → 快速热交换<br>
                • 塑料/橡胶 (0.1–0.5) → 慢速热交换<br>
                • 织物 (0.03–0.1) → 极慢热交换
              </td>
              <td>
                需要 0.5–2秒 的接触时间窗口，无法做毫秒级反应
              </td>
            </tr>
            <tr>
              <td><b>安全检测</b></td>
              <td>
                避免抓烫的物体 (&gt;60°C)，检测电机/驱动器过热
              </td>
              <td>
                手套/包覆材料会延长热传导路径，需要差分测量
              </td>
            </tr>
            <tr>
              <td><b>任务适应</b></td>
              <td>
                根据材质调整抓取策略（金属→大预紧力，织物→小预紧力）
              </td>
              <td>
                与视触胶体有矛盾：胶体温度变化会同时影响视触测量和温度测量
              </td>
            </tr>
          </tbody>
        </table>

        <h5>推荐决策树：你的应用需要温度感知吗？</h5>
        <pre><code>你的应用场景是？
  │
  ├─ <b>工业装配 / 实验室操作</b>
  │   └─ ❌ <b>不需要温度</b>（材质已知，环境可控）
  │       理由：任务中的物体材质是预先确定的
  │
  ├─ <b>家庭服务 / 通用操作</b>
  │   └─ ⚠️  <b>可选（Phase 4+）</b>
  │       优先级: wrist_FT &gt; 指尖力 &gt; 温度
  │       理由：力学闭环是基础能力，温度是锦上添花
  │       配置：1–2 个 NTC 热敏电阻（指尖侧面 / 手腕）
  │       用途：材质识别 → 调整抓取参数
  │
  └─ <b>厨房 / 医疗 / 安全关键应用</b>
      └─ ✅ <b>需要温度（Phase 3–4）</b>
          理由：必须避免烫伤/冻伤，或测量体温
          配置：方案 A（1–2 个热敏电阻）或方案 B（多点温度阵列）
          用途：安全检测（过热预警）+ 材质识别
</code></pre>

        <h5>最小配置方案（如果要纳入）</h5>
        <p><b>传感器</b>：</p>
        <ul>
          <li>1–2 个小型热电偶或 NTC 热敏电阻（成本 $1–5/个）</li>
          <li>位置：指尖侧面（避开视触胶体）或手腕</li>
          <li>采样率：1–10Hz（够用，不需要高频）</li>
        </ul>
        <p><b>集成到架构</b>：</p>
        <ul>
          <li>Level-C 输入：RGB + task state + wrist_FT 统计特征 <b>+ 温度梯度 (T_fingertip - T_ambient)</b></li>
          <li>输出：<code>material_class</code> (metal/plastic/wood/fabric/ceramic) → 调整抓取参数</li>
          <li>RM 增加：<code>thermal_safety</code> 判据（过热 → 触发 release）</li>
        </ul>

        <h5>时间常数对比（为什么温度无法参与高频闭环）</h5>
        <table>
          <thead>
            <tr>
              <th>模态</th>
              <th>时间常数</th>
              <th>适用闭环频率</th>
              <th>用途</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>力/力矩</td>
              <td>1–10ms</td>
              <td>500–1000Hz (Level-A)</td>
              <td>安全反射、止损</td>
            </tr>
            <tr>
              <td>触觉（压力/剪切）</td>
              <td>5–20ms</td>
              <td>60–200Hz (Level-B)</td>
              <td>防滑、夹持力调度</td>
            </tr>
            <tr style="background-color: rgba(255, 193, 7, 0.15);">
              <td><b>温度</b></td>
              <td><b>0.5–5s</b></td>
              <td><b>0.2–2Hz</b></td>
              <td>材质识别、安全检测（语义特征）</td>
            </tr>
            <tr>
              <td>视觉</td>
              <td>30–100ms</td>
              <td>5–30Hz (Level-C)</td>
              <td>全局几何、策略决策</td>
            </tr>
          </tbody>
        </table>
        <blockquote>
          <p>
            <b>关键洞察</b>：温度的时间常数比力学慢 <b>100–1000 倍</b>，因此它只能作为<strong>语义输入</strong>（Level-C），
            用于材质分类、任务初始化参数选择、或安全检测，<strong>不参与毫秒级的接触稳定闭环</strong>。
          </p>
        </blockquote>

        <h4 id="ultrasonic-sensing">3.2.2 超声感知：非接触探测 × 内部结构（场景特定可选）</h4>
        <p>
          超声传感器通过<b>声波反射</b>可以实现非接触距离测量、材料内部结构探测、以及声学特性识别（空心 vs 实心、液体检测）。
          相比温度，超声的响应速度更快（毫秒级），但需要<b>声学耦合</b>且<b>方向性强</b>，更适合特定任务场景。
        </p>

        <h5>超声感知的价值与局限</h5>
        <table>
          <thead>
            <tr>
              <th>应用场景</th>
              <th>价值</th>
              <th>局限</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>非接触距离测量</b></td>
              <td>
                • 手指接近物体前的障碍检测（5–30cm）<br>
                • 抓取前的距离估计 → 优化 approach 路径<br>
                • 避免碰撞（尤其在视觉遮挡时）
              </td>
              <td>
                • 空气中衰减大（需要 &lt;30cm）<br>
                • 方向性强（±15–30°锥角）<br>
                • 不适合复杂几何（多次反射）
              </td>
            </tr>
            <tr>
              <td><b>材质/内部结构</b></td>
              <td>
                • 空心 vs 实心（声阻抗差异）<br>
                • 液体检测（瓶子里有没有水）<br>
                • 厚度测量（墙壁/容器壁厚）<br>
                • 多层结构识别
              </td>
              <td>
                • 需要接触或极近距离（&lt;1cm）<br>
                • 需要耦合介质（凝胶/水）或密贴接触<br>
                • 高频超声（&gt;1MHz）穿透性差
              </td>
            </tr>
            <tr>
              <td><b>声学特性识别</b></td>
              <td>
                • 区分金属/塑料/木材（声速不同）<br>
                • 识别液体/气体/固体<br>
                • 结合温度 → 更准确的材质分类
              </td>
              <td>
                • 需要已知参考声速数据库<br>
                • 表面粗糙度影响反射<br>
                • 软质材料（织物/海绵）吸声严重
              </td>
            </tr>
          </tbody>
        </table>

        <h5>推荐决策：超声 vs 温度（如何选择）</h5>
        <pre><code>你的任务需要什么？
  │
  ├─ <b>接触前的距离/障碍感知</b>
  │   └─ ✅ <b>超声更合适</b>（非接触，ms 级响应）
  │       配置：指尖前端 1–2 个超声测距模块（40kHz，5–30cm 量程）
  │       用途：approach 优化、避碰、抓取前距离估计
  │
  ├─ <b>接触后的材质识别</b>
  │   └─ ⚖️  <b>温度 + 视觉更简单</b>（超声需要耦合）
  │       • 温度：热导率 → metal/plastic/fabric
  │       • 超声：需要密贴接触 → 空心/实心/液体
  │       建议：优先温度 + RGB；特殊需求（液体检测）才加超声
  │
  ├─ <b>内部结构/液体检测</b>（瓶子里有没有水、空心 vs 实心）
  │   └─ ✅ <b>超声必需</b>（唯一可行方案）
  │       配置：高频超声探头（1–5MHz）+ 接触式布置
  │       注意：需要声学耦合（凝胶或水膜）
  │
  └─ <b>热安全检测</b>（避免烫伤）
      └─ ✅ <b>温度必需</b>（超声无法测温）
</code></pre>

        <h5>最小配置方案（如果要纳入超声）</h5>
        <p><b>方案 A：非接触测距</b>（推荐用于 approach 优化）</p>
        <ul>
          <li>传感器：1–2 个超声测距模块（HC-SR04 类，40kHz，成本 $2–5/个）</li>
          <li>位置：手腕或指尖前端（朝向接近方向）</li>
          <li>量程：5–30cm（最佳工作距离）</li>
          <li>采样率：10–50Hz（够用）</li>
          <li>用途：Level-C 输入 → approach 路径优化、避碰</li>
        </ul>

        <p><b>方案 B：接触式材质/液体检测</b>（特殊应用）</p>
        <ul>
          <li>传感器：高频超声探头（1–5MHz，成本 $10–50/个）</li>
          <li>位置：指尖表面（需要与物体密贴）</li>
          <li>耦合：需要凝胶或水膜（维护成本高）</li>
          <li>用途：空心/实心判别、液体检测、厚度测量</li>
          <li><b>工程挑战</b>：耦合介质维护、清洁、耐用性</li>
        </ul>

        <h5>超声 vs 温度 vs 力学：时间常数对比</h5>
        <table>
          <thead>
            <tr>
              <th>模态</th>
              <th>响应时间</th>
              <th>测量距离</th>
              <th>主要用途</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>力/力矩</td>
              <td>1–10ms</td>
              <td>接触（0mm）</td>
              <td>闭环控制、止损</td>
            </tr>
            <tr>
              <td><b>超声（测距）</b></td>
              <td><b>~10ms</b></td>
              <td><b>5–300mm</b></td>
              <td>非接触距离、避碰</td>
            </tr>
            <tr>
              <td><b>超声（材质）</b></td>
              <td><b>~10–50ms</b></td>
              <td><b>接触（0–1mm）</b></td>
              <td>内部结构、液体检测</td>
            </tr>
            <tr>
              <td>温度</td>
              <td>0.5–5s</td>
              <td>接触（0mm）</td>
              <td>材质识别（热导率）、安全</td>
            </tr>
          </tbody>
        </table>

        <blockquote>
          <p>
            <b>工程建议</b>：
            <ul style="margin: 0.5em 0; padding-left: 1.5em;">
              <li>优先级：<b>力学 &gt; wrist_FT &gt; 指尖力 &gt; 温度 &gt; 超声</b></li>
              <li>超声更适合<strong>特定场景</strong>（复杂环境避碰、液体检测、内部结构探测）</li>
              <li>通用家庭服务：温度 + RGB 已够用于材质识别；超声是锦上添花</li>
              <li>厨房/医疗：温度（热安全）优先级高于超声</li>
              <li>工业/仓储（复杂环境）：超声测距对 approach 优化有明确价值</li>
            </ul>
          </p>
        </blockquote>

        <h5>超声的特定场景深入分析：什么任务真正需要它？</h5>
        <p>
          下面用<b>具体任务案例</b>说明超声的独特价值——即<strong>其他传感器做不到或做不好的事</strong>。
        </p>

        <h6>场景 1：液体容器操作（厨房/服务机器人）</h6>
        <table>
          <thead>
            <tr>
              <th>任务</th>
              <th>挑战</th>
              <th>超声的作用</th>
              <th>替代方案的局限</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>倒水/倒饮料</b></td>
              <td>
                • 需要实时监测液位（避免溢出）<br>
                • 视觉看不到瓶/杯内部<br>
                • 重量变化滞后且不精确
              </td>
              <td>
                超声探头朝向容器内部，实时测量液面距离：<br>
                • 距离减小 → 液位上升<br>
                • 距离稳定 → 液位到达目标<br>
                • 响应时间：~10ms（足够快）
              </td>
              <td>
                • <b>视觉</b>：遮挡、反光、透明液体难识别<br>
                • <b>重量</b>：需要力传感器 + 容器标定，滞后<br>
                • <b>倾斜角估计</b>：误差大，不可靠
              </td>
            </tr>
            <tr>
              <td><b>检测容器是否空</b></td>
              <td>
                抓取前不知道瓶子/盒子里是否有东西
              </td>
              <td>
                轻拍容器 + 超声：<br>
                • 空容器：声波穿透，回波单一<br>
                • 有液体：声阻抗变化，回波特征不同<br>
                • 无需打开/倾斜
              </td>
              <td>
                • <b>重量</b>：需要已知容器自重<br>
                • <b>视觉</b>：不透明容器看不到<br>
                • <b>晃动</b>：需要复杂动作，可能洒出
              </td>
            </tr>
          </tbody>
        </table>

        <h6>场景 2：视觉盲区的几何探测（复杂抓取）</h6>
        <table>
          <thead>
            <tr>
              <th>任务</th>
              <th>挑战</th>
              <th>超声的作用</th>
              <th>为什么视觉/触觉不够</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>抓取遮挡物体</b><br>（柜子深处、抽屉里）</td>
              <td>
                • 相机视角被遮挡<br>
                • 物体背面几何不可见<br>
                • 需要"盲抓"
              </td>
              <td>
                手指上的超声探头：<br>
                • 在 approach 过程中扫描周围 5–15cm<br>
                • 检测障碍物（墙壁、其他物体）<br>
                • 估计目标物体的大致位置和尺寸
              </td>
              <td>
                • <b>视觉</b>：被遮挡，看不到<br>
                • <b>触觉</b>：需要先接触，来不及调整<br>
                • <b>wrist_FT</b>：只有接触后才有信号
              </td>
            </tr>
            <tr>
              <td><b>手掌内侧/手指间探测</b></td>
              <td>
                抓取过程中，手掌内侧是相机盲区
              </td>
              <td>
                手掌内侧安装超声：<br>
                • 检测物体与手掌的距离<br>
                • 判断是否完全进入抓取区域<br>
                • 避免夹空
              </td>
              <td>
                • <b>腕部相机</b>：角度有限，手掌内侧仍是盲区<br>
                • <b>触觉</b>：接触后才知道，已经晚了
              </td>
            </tr>
          </tbody>
        </table>

        <h6>场景 3：软硬度/成熟度估计（非破坏性检测）</h6>
        <table>
          <thead>
            <tr>
              <th>任务</th>
              <th>挑战</th>
              <th>超声的作用</th>
              <th>触觉方案的问题</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>水果成熟度检测</b></td>
              <td>
                • 需要判断软硬度（成熟/过熟/生）<br>
                • 不能捏坏（触觉需要施加力）
              </td>
              <td>
                超声测量声速/衰减：<br>
                • 硬（生）：声速快，反射强<br>
                • 软（熟）：声速慢，衰减大<br>
                • 无需施加压力
              </td>
              <td>
                • <b>触觉</b>：需要捏压 → 可能损坏<br>
                • <b>视觉</b>：只能看外观，内部软硬度看不出<br>
                • <b>温度</b>：与成熟度无直接关系
              </td>
            </tr>
            <tr>
              <td><b>面包新鲜度</b></td>
              <td>
                新鲜面包柔软，陈旧面包变硬
              </td>
              <td>
                超声探测内部密度/气孔结构：<br>
                • 新鲜：多气孔，声波散射<br>
                • 陈旧：密实，声波穿透性强
              </td>
              <td>
                • <b>触觉</b>：表皮摸起来都差不多<br>
                • <b>视觉</b>：外观无明显差异
              </td>
            </tr>
            <tr>
              <td><b>包裹/盒子内容物检测</b></td>
              <td>
                • 不能打开看<br>
                • 需要判断是实心还是空心<br>
                • 判断是硬物还是软物
              </td>
              <td>
                超声穿透检测：<br>
                • 空：回波单一且清晰<br>
                • 硬物：强反射<br>
                • 软物：吸声，回波弱
              </td>
              <td>
                • <b>重量</b>：需要拿起来，且不知道内容物类型<br>
                • <b>晃动</b>：并非所有物体都会响<br>
                • <b>视觉</b>：不透明包装看不到
              </td>
            </tr>
          </tbody>
        </table>

        <h6>场景 4：复杂环境的 approach 优化（工业/仓储）</h6>
        <table>
          <thead>
            <tr>
              <th>场景</th>
              <th>挑战</th>
              <th>超声的作用</th>
              <th>为什么必须是超声</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>货架深处抓取</b></td>
              <td>
                • 狭窄空间<br>
                • 多次碰撞风险<br>
                • 相机视角受限
              </td>
              <td>
                多方向超声测距：<br>
                • 前方：目标物体距离<br>
                • 侧方：与货架壁的距离<br>
                • 实时调整 approach 轨迹
              </td>
              <td>
                • <b>视觉</b>：深度估计误差大（单目）；遮挡严重<br>
                • <b>触觉/FT</b>：碰到才知道，已经晚了<br>
                • <b>激光雷达</b>：成本高、体积大、不适合手指
              </td>
            </tr>
            <tr>
              <td><b>插拔操作</b><br>（插头、USB、钥匙）</td>
              <td>
                • 孔深度不可见<br>
                • 需要精确对齐<br>
                • 插入深度反馈
              </td>
              <td>
                插入物前端装超声：<br>
                • 测量到孔底的距离<br>
                • 监测插入深度<br>
                • 检测是否到位
              </td>
              <td>
                • <b>视觉</b>：孔内部看不到<br>
                • <b>wrist_FT</b>：只能感知阻力，不知道深度<br>
                • <b>proprio (q)</b>：只知道关节位置，不知道实际插入深度（可能卡住）
              </td>
            </tr>
            <tr>
              <td><b>夹持力预判</b></td>
              <td>
                在接触前估计需要多大夹持力
              </td>
              <td>
                超声估计物体尺寸/形状：<br>
                • 大物体 → 需要大开合度<br>
                • 估计接触面积 → 预设夹持力
              </td>
              <td>
                • <b>视觉</b>：尺寸估计有误差；遮挡时更不准<br>
                • <b>触觉</b>：接触后才知道，可能已经夹坏了
              </td>
            </tr>
          </tbody>
        </table>

        <h6>场景 5：滑移早期预警（补充触觉盲区）</h6>
        <p><b>任务</b>：在物体开始滑移之前检测风险</p>
        <ul>
          <li>
            <b>触觉的局限</b>：触觉传感器检测的是<strong>已经发生的滑移</strong>（切向力变化、接触 patch 移动）；
            当触觉检测到滑移时，物体可能已经开始掉落。
          </li>
          <li>
            <b>超声的补充</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>手指侧面装超声，持续测量<strong>手指与物体表面的微小距离变化</strong></li>
              <li>当距离开始<strong>缓慢增大</strong>（亚毫米级）→ 物体正在"松动"，但还没完全滑移</li>
              <li>提前 50–200ms 触发预紧力增大 → 避免掉落</li>
            </ul>
          </li>
          <li>
            <b>为什么触觉做不到</b>：触觉需要接触，但"即将脱离接触"这个状态是触觉的盲区；
            超声可以测量 0–5mm 的微小间隙，填补这个盲区。
          </li>
        </ul>

        <h6>工程实现建议（如果要做超声）</h6>
        <table>
          <thead>
            <tr>
              <th>场景类别</th>
              <th>推荐配置</th>
              <th>成本</th>
              <th>集成难度</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>液体容器操作</b></td>
              <td>1–2 个超声测距模块（40kHz）<br>安装位置：指尖前端，朝向容器内部</td>
              <td>$2–5/个</td>
              <td>低（简单测距）</td>
            </tr>
            <tr>
              <td><b>视觉盲区探测</b></td>
              <td>2–4 个超声测距模块<br>安装位置：手指侧面、手掌内侧</td>
              <td>$10–20 总计</td>
              <td>中（需要多传感器融合）</td>
            </tr>
            <tr>
              <td><b>软硬度/内部结构</b></td>
              <td>高频超声探头（1–5MHz）<br>安装位置：指尖表面</td>
              <td>$10–50/个</td>
              <td>高（需要耦合凝胶、信号处理复杂）</td>
            </tr>
            <tr>
              <td><b>复杂环境 approach</b></td>
              <td>2–3 个多方向超声测距<br>安装位置：手腕、指尖前端/侧面</td>
              <td>$5–15 总计</td>
              <td>中（需要轨迹规划集成）</td>
            </tr>
            <tr>
              <td><b>滑移早期预警</b></td>
              <td>高精度超声测距（0.1mm 分辨率）<br>安装位置：指尖侧面</td>
              <td>$10–20/个</td>
              <td>高（需要高采样率 + 信号滤波）</td>
            </tr>
          </tbody>
        </table>

        <blockquote>
          <p>
            <b>总结</b>：超声的核心价值在于<strong>非接触感知</strong>和<strong>内部结构探测</strong>——这是视觉、触觉、温度都做不到的。
            但它<b>不是通用传感器</b>，只在上述特定任务中才体现明确的投资回报率（ROI）。
            <br><br>
            <b>推荐策略</b>：
            <ul style="margin: 0.5em 0; padding-left: 1.5em;">
              <li>MVS–Phase 3：专注力学闭环（这是基础）</li>
              <li>Phase 4：如果有<strong>明确的液体操作/复杂环境需求</strong>，加入超声测距（低成本、低风险）</li>
              <li>Phase 5+：如果有<strong>特殊需求</strong>（软硬度检测、内部结构），考虑高频超声（高成本、高维护）</li>
            </ul>
          </p>
        </blockquote>

        <h3 id="pro">3.3 Level-2（工程化 Pro：长时部署与健康管理）</h3>
        <ul>
          <li><b>热与健康监测</b>：<code>temp_motor_i</code>、<code>over_current_count</code>、<code>stall_time_ms</code>。</li>
          <li><b>冗余观测</b>：关键关节 <code>effort/current</code> 的统计漂移，形成 <code>sensor_health</code>。</li>
        </ul>
        <p>
          <b>落地要点</b>：把“耗材化/会坏”写进系统。<br>
          视触觉（凝胶/表皮）与线缆在长期部署中就是耗材；因此需要把 <code>sensor_health</code>、<code>recalib_required</code>、以及更换后的 <code>calib_version</code> 当作数据的一等公民写进 episode metadata。
        </p>
        <p>
          <b>视触相关（建议新增到 episode metadata）</b>：<code>gel_id</code> / <code>gel_batch</code> / <code>temp_gel</code> / <code>precondition_ok</code>（开机预调理脚本是否通过）；
          同时 teacher 侧建议记录 <code>teacher_version</code> 与 <code>teacher_uncertainty</code>（或置信度），避免“材料状态漂了但标签看起来还很自信”。
        </p>

        <h2 id="loops">4) 三层闭环（Level-A/B/C）与职责边界</h2>
        <h3 id="level-a">4.1 Level-A：安全反射层（500–1000Hz）</h3>
        <p>目标：防损坏、防卡死、防过热，毫秒级止损。</p>
        <ul>
          <li><b>输入</b>：<code>motor_current/joint_effort</code>、<code>qdot</code>、温度、软硬限位。</li>
          <li><b>输出</b>：限流、急停、退避（backoff）。</li>
        </ul>

        <h3 id="level-b">4.2 Level-B：触觉协调层（60–200Hz）</h3>
        <p>目标：防滑（slip control）、夹持力调度、微调接触几何。</p>
        <ul>
          <li><b>输入</b>：剪切/压力阵列（主力） + <code>effort/current</code>（冗余） +（可选）视触觉特征。</li>
          <li><b>输出</b>：夹持力（或关节闭合量）微调、接触姿态微调。</li>
        </ul>

        <h4 id="level-b-force">4.2.1 精细力控子模式（Level-B-Force）</h4>
        <p>
          对 <code>twist</code>/<code>insertion</code>/<code>pry</code> 等精细力控任务，Level-B 需要切换到力控子模式，要求更精确的力/力矩闭环。
          此时 <code>current/effort</code> 的弱 proxy 不足，<b>必须引入 <code>wrist_FT</code>（6D F/T）</b>。
        </p>

        <h5>精细力控闭环结构图</h5>
        <pre><code>┌─────────────────────────────────────────────────────────────────────────────┐
│                      <b>精细力控闭环 (Level-B-Force)</b>                         │
│              适用任务: twist / insertion / pry / fine press / pull            │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  <b>传感输入层</b>                                                                │
└─────────────────────────────────────────────────────────────────────────────┘
     ┌─────────────────┐   ┌───────────────────┐   ┌──────────────────┐
     │  wrist_FT (6D)  │   │ 指尖力 (可选)     │   │  q / qdot        │
     │  [Fx,Fy,Fz,     │   │ 法向 + 切向 ×2    │   │  关节位置/速度   │
     │   τx,τy,τz]     │   │                   │   │                  │
     └────────┬────────┘   └─────────┬─────────┘   └────────┬─────────┘
              │                      │                       │
              └──────────────────────┴───────────────────────┘
                                     │
                             实时测量 (60–200Hz)
                                     ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  <b>状态估计 & 误差计算</b>                                                       │
└─────────────────────────────────────────────────────────────────────────────┘
     ┌────────────────────────────────────────────────────────────────┐
     │  • 接触力/力矩估计: F_contact, τ_contact                       │
     │  • 误差计算:                                                    │
     │    - twist:    e_τz = τz_cmd - τz_measured                     │
     │    - press:    e_Fz = Fz_cmd - Fz_measured                     │
     │    - insertion: e_F = [Fx,Fy,Fz] - [Fx_cmd, Fy_cmd, Fz_cmd]   │
     │  • 风险评估: slip_risk, jam_risk (从 Student 或规则)           │
     └────────────────────────────────────────────────────────────────┘
                                     │
                                误差信号 ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  <b>控制律选择 & 参数调整</b>                                                     │
└─────────────────────────────────────────────────────────────────────────────┘
     ┌────────────────────────────────────────────────────────────────┐
     │  <b>控制律类型:</b>                                                  │
     │  ┌──────────────────────────────────────────────────────────┐  │
     │  │  阻抗控制 (Impedance):  τ = K(x_d - x) + B(ẋ_d - ẋ) + F_ext │
     │  │  导纳控制 (Admittance): ẍ = M⁻¹(F_ext - Kx - Bẋ)           │
     │  │  混合控制 (Hybrid):     位置主方向 + 力从方向              │
     │  └──────────────────────────────────────────────────────────┘  │
     │                                                                 │
     │  <b>任务特定映射:</b>                                                │
     │  • twist      → τz 闭环 + slip_risk 补偿 (增大 Fz 预紧)       │
     │  • insertion  → Fz 限幅 + Fx/Fy 对中 (阻抗控制)                │
     │  • press      → Fz 闭环 (PID 或力限幅)                          │
     │  • pry        → τ 限幅 + 姿态微调                               │
     └────────────────────────────────────────────────────────────────┘
                                     │
                              控制指令 ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  <b>输出 & 执行</b>                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
     ┌────────────────────────────────────────────────────────────────┐
     │  输出形式:                                                       │
     │  • 末端 compliance 调整 (Δx_ee, Δorientation)                   │
     │  • 或关节力矩指令 (τ_joint) → Level-A 安全限幅                  │
     │                                                                 │
     │  安全约束 (Level-C 下发):                                        │
     │  • F_max, τ_max (力/力矩上限)                                   │
     │  • slip_risk_threshold (触发增大 Fz)                            │
     │  • jam 检测 → 立即触发 backoff                                  │
     └────────────────────────────────────────────────────────────────┘
                                     │
                                执行层 ↓
                      ┌────────────────────────────┐
                      │  Level-A (安全反射)        │
                      │  → 执行器 → 物理世界       │
                      └────────────────────────────┘

<b>关键要点:</b>
  • wrist_FT 必选：twist/insertion/pry 无法用 current/effort 替代（精度差 10–100×）
  • 阻抗 vs 导纳：阻抗控制适合刚性环境（insertion），导纳适合柔性/未知刚度
  • slip_risk 补偿：当 slip_risk &gt; 阈值时，自动增大法向预紧 Fz
  • 可降级：wrist_FT 失效 → 回退简单任务（不做精细力控）
</code></pre>

        <h5>典型控制律示例</h5>
        <table>
          <thead>
            <tr>
              <th>任务原语</th>
              <th>控制目标</th>
              <th>控制律类型</th>
              <th>关键闭环信号</th>
              <th>成功/失败判据</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>twist</code>（擰瓶盖）</td>
              <td>维持 τz 在目标范围，同时监控 slip_risk</td>
              <td>扭矩闭环：τz_cmd → τz_measured</td>
              <td><code>wrist_FT.τz</code></td>
              <td>角度达标 且 <code>slip_risk &lt; 0.3</code></td>
            </tr>
            <tr>
              <td><code>press</code>（精密夹持）</td>
              <td>限制 Fz，维持预紧力</td>
              <td>力闭环：F_cmd → F_measured</td>
              <td>指尖法向力 或 <code>wrist_FT.Fz</code></td>
              <td><code>contact_confidence &gt; 0.8</code> 且 <code>|F_error| &lt; ε</code></td>
            </tr>
            <tr>
              <td><code>insertion</code>（精密插入）</td>
              <td>限制 Fz，同时用 Fx/Fy/τx/τy 做对中</td>
              <td>阻抗控制：位置主/力从</td>
              <td><code>wrist_FT</code> (6D)</td>
              <td>深度达标 且 无 <code>jam</code> 事件</td>
            </tr>
            <tr>
              <td><code>pry</code>（撬开）</td>
              <td>控制力矩，限制峰值力</td>
              <td>力矩限幅 + 姿态微调</td>
              <td><code>wrist_FT</code> (6D) + 安全限位</td>
              <td>约束解除 且 无 <code>safety_trip</code></td>
            </tr>
          </tbody>
        </table>

        <h5>职责边界明确化</h5>
        <p>Level-B 的"微调接触几何"具体指：</p>
        <ul>
          <li><b>夹持力调度</b>：指尖法向力 → 关节闭合量（或力矩指令）</li>
          <li><b>接触姿态微调</b>：<code>wrist_FT</code> 的侧向分量（Fx/Fy/τx/τy）→ 手腕姿态微调（对中/消除 misalignment）</li>
          <li><b>防滑响应</b>：<code>slip_risk</code> 高 → 增大法向预紧或降低切向速度</li>
        </ul>
        <blockquote>
          <p>
            <b>关键区别</b>：简单抓取/防滑可用 <code>current/effort</code>；精细力控（twist/insertion/pry）必须用 <code>wrist_FT</code> 才能做到毫牛级闭环与多轴解耦。
          </p>
        </blockquote>

        <h3 id="level-c">4.3 Level-C：语义策略层（5–15Hz）</h3>
        <p>目标：任务理解、子任务切换、与 VLA/LLM 高层决策对接。</p>
        <ul>
          <li><b>输入</b>：视觉 +（可选）语言指令/任务状态 +（可选）手腕 F/T 统计特征。</li>
          <li><b>输出</b>：子目标（grasp pose / schedule / retreat policy）以及对 A/B 的参数下发（上限、恢复路径）。</li>
        </ul>
        <blockquote>
          <p>关键点：Level-C 不直接管“接触瞬间怎么稳住”，它管的是“何时进入接触、失败后走哪条恢复路径”。</p>
        </blockquote>

        <h2 id="causality">5) 人形视角：手是“物理因果接口”</h2>
        <p>
          对人形机器人来说，手的职责是把意图转成物理世界会响应的原因（力、力矩、接触约束）。
          最小语义接口可以写成 6D wrench：
        </p>
        <p>
          \[
          w = [F_x, F_y, F_z, \tau_x, \tau_y, \tau_z]^T
          \]
        </p>
        <p>
          push/pull/press/twist/pry 本质是在控制 \(w\) 的不同分量。滑移的物理边界（简化）：
          \[
          \|f_t\| \le \mu f_n
          \]
          因而 slip detection 也是在估计：是否进入 sliding，以及离边界有多近（<code>slip_risk</code>）。
        </p>

        <h3 id="primitives">5.1 物理原语（Physical Primitives）词汇表</h3>
        <p>
          下面把文中出现的“物理原语”统一成可落地定义：每个词对应你想改变的物理量（wrench/约束/接触模式）以及它依赖的关键可观测信号。
          原语可以作为早期 <b>rule-based policy</b>，也可以作为 VLA policy 的高层动作空间（primitive switching）。
        </p>
        <table class="primitives-table">
          <colgroup>
            <col style="width: 8%;">
            <col style="width: 16%;">
            <col style="width: 14%;">
            <col style="width: 16%;">
            <col style="width: 18%;">
            <col style="width: 28%;">
          </colgroup>
          <thead>
            <tr>
              <th>原语</th>
              <th>直白定义<span class="th-sub">你在物理上做什么</span></th>
              <th>目标<span class="th-sub">改变什么</span></th>
              <th>闭环控制律<span class="th-sub">怎么闭环</span></th>
              <th>关键闭环信号<span class="th-sub">最低配</span></th>
              <th>成功/失败判据<span class="th-sub">触发恢复</span></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>press</code></td>
              <td>沿接触法向"压下去"，建立/维持法向力</td>
              <td>提高 \(f_n\)，增加摩擦预算（降低 slip_risk）</td>
              <td>力闭环：F_cmd → F_measured（或 current 限幅）</td>
              <td><code>current/effort</code>（法向 proxy）、<code>q/qdot</code>；高精度：指尖法向力或 <code>wrist_FT.Fz</code></td>
              <td><b>成功</b>：<code>contact_confidence &gt; 0.8</code> 且 F_error &lt; ε<br><b>失败</b>：过力/jam → <code>backoff</code>；slip 仍高→ <code>wedge</code>/<code>regrasp</code></td>
            </tr>
            <tr>
              <td><code>pull</code></td>
              <td>沿某方向"拉"，尝试解除约束或拉出物体</td>
              <td>控制切向力 \(f_t\)，改变约束反力</td>
              <td>力闭环（切向）：f_t_cmd → f_t_measured；或阻抗控制</td>
              <td><code>wrist_FT</code>（强烈推荐）、<code>current/effort</code></td>
              <td><b>成功</b>：目标位移达标 且 <code>slip_risk &lt; 0.3</code><br><b>失败</b>：滑移/脱手→增大 <code>press</code> 或 <code>regrasp</code></td>
            </tr>
            <tr>
              <td><code>push</code></td>
              <td>沿某方向"推"，让物体/机构进入更可控的约束状态</td>
              <td>改变接触约束与几何关系（让任务更可解）</td>
              <td>位置控制 + 力限幅（hybrid control）</td>
              <td><code>rgb_wrist</code> + <code>current/effort</code>（接触/阻力 proxy）；高精度：<code>wrist_FT</code></td>
              <td><b>成功</b>：目标约束状态达成 且 无 jam<br><b>失败</b>：顶死/卡住→ <code>backoff</code>；偏斜→ <code>re-approach</code></td>
            </tr>
            <tr>
              <td><code>wedge</code></td>
              <td>"楔入/撬开"式接触：用边缘/角点制造几何杠杆</td>
              <td>把不可见/难抓的几何变成可抓（解锁/起缝）</td>
              <td>力/力矩限幅 + 姿态微调（限制峰值力）</td>
              <td><code>wrist_FT</code>（强烈推荐）、<code>current/effort</code></td>
              <td><b>成功</b>：缝隙打开 或 接触状态改变<br><b>失败</b>：过力/损伤风险→限力 <code>backoff</code>；slip→ <code>press</code>/<code>regrasp</code></td>
            </tr>
            <tr>
              <td><code>twist</code></td>
              <td>绕轴旋转（例如拧盖/旋钮）</td>
              <td>控制 \(\tau_z\)（扭矩）并维持接触模式为 stick</td>
              <td><b>扭矩闭环：τz_cmd → τz_measured</b>（<code>wrist_FT</code> 必选）</td>
              <td><code>wrist_FT.τz</code>（<b>必选</b>）；次选：<code>current/effort</code>（扭矩弱 proxy）</td>
              <td><b>成功</b>：角度达标 且 <code>slip_risk &lt; 0.3</code><br><b>失败</b>：slip→先 <code>press</code> 提升摩擦；jam→ <code>backoff</code> + 重新对齐</td>
            </tr>
            <tr>
              <td><code>pry</code></td>
              <td>"撬"：绕支点施加力矩，解除卡扣/粘连</td>
              <td>改变约束反力与接触点（高风险原语）</td>
              <td><b>力矩闭环 + 峰值限幅</b>（阻抗控制）</td>
              <td><code>wrist_FT</code>（<b>必选</b>）、安全限位/温度</td>
              <td><b>成功</b>：约束解除 且 无 <code>safety_trip</code><br><b>失败</b>：过力/过矩→立刻 <code>backoff</code>；损伤风险→终止并报警</td>
            </tr>
            <tr>
              <td><code>drag</code></td>
              <td>贴着表面"拖拽/扫过"以定位或产生摩擦信息</td>
              <td>用可控滑移获取信息/对齐（信息驱动原语）</td>
              <td>位置控制 + 法向力限幅（保持接触但允许滑移）</td>
              <td><code>rgb_wrist</code> + <code>current/effort</code>；高精度：指尖触觉或 <code>wrist_FT</code></td>
              <td><b>成功</b>：完成扫描区域 或 找到目标特征<br><b>失败</b>：摩擦过大→减速/减力；抓取不稳→先 <code>press</code></td>
            </tr>
            <tr>
              <td><code>regrasp</code></td>
              <td>重新抓（松开→调整接触点→再抓）</td>
              <td>把接触几何重置到更稳定区域</td>
              <td>序列控制：<code>reopen</code> → 视觉定位 → <code>press</code></td>
              <td><code>rgb_wrist</code> + <code>q/qdot</code> + <code>current/effort</code></td>
              <td><b>成功</b>：<code>contact_confidence</code> 提升 且 <code>slip_risk</code> 降低<br><b>失败</b>：重复失败→切换 <code>wedge</code> 或改变 approach 方向</td>
            </tr>
            <tr>
              <td><code>backoff</code></td>
              <td>后退/卸载力（退避）</td>
              <td>快速止损，解除 jam/过力风险（Level-A 常用）</td>
              <td>位置撤退 + 力卸载监控（验证力是否下降）</td>
              <td><code>current/effort</code> + <code>qdot</code> + 安全事件；高精度：<code>wrist_FT</code></td>
              <td><b>成功</b>：<code>current/effort</code> 降至安全范围 且 <code>qdot</code> 响应正常<br><b>失败</b>：退避后仍异常→标记 <code>sensor_health</code> 或请求人工介入</td>
            </tr>
            <tr>
              <td><code>reopen</code></td>
              <td>张开手指/减小夹持（释放接触）</td>
              <td>解除卡住/重置接触</td>
              <td>位置控制（张开）+ 力卸载验证</td>
              <td><code>q</code> + <code>current/effort</code></td>
              <td><b>成功</b>：<code>current/effort</code> 降至基线 且 <code>q</code> 达到开启位置<br><b>失败</b>：释放无效（仍有阻力）→可能几何卡死，转 <code>backoff</code> + 改路径</td>
            </tr>
            <tr>
              <td><code>re-approach</code></td>
              <td>重新接近（换角度/路径再次进入接触）</td>
              <td>降低 misalignment/occlusion，获得更好接触几何</td>
              <td>视觉伺服 + 路径规划（重新定位 grasp pose）</td>
              <td><code>rgb_static</code>/<code>rgb_wrist</code> + <code>q</code></td>
              <td><b>成功</b>：接触建立 且 <code>misalignment</code> 指标改善<br><b>失败</b>：重复 misalignment→调整目标姿态或先 <code>drag</code> 探索</td>
            </tr>
          </tbody>
        </table>

        <h2 id="rm">6) RM-in-loop：自动切段、挑 hard cases、触发自恢复</h2>
        <p>
          把 RM 当成“质量裁判”：部署时不仅做任务，还能自动生成高价值训练数据，并减少人工介入。
        </p>
        <ul>
          <li>自动切段（streaming → episode/subtask）</li>
          <li>自动挑 hard cases（对训练最值钱）</li>
          <li>自动触发恢复策略（减少 human intervention）</li>
        </ul>
        <p>建议 RM 多头输出，而不是只输出一个标量：</p>
        <ul>
          <li><code>progress</code>、<code>quality</code>、<code>recoverability</code>、<code>failure_mode</code></li>
          <li>（强烈建议）<code>primitive</code> / <code>contact_mode</code> / <code>slip_risk</code>：把物理因果写进标签体系</li>
        </ul>
        <p>
          <b>面向 VLA 的对齐说明：RM 在前沿里通常以“critic/复盘”形态出现</b>。<br>
          在具身/机器人学习前沿，很多团队并不把 RM 当作“在线 RL 的奖励函数”直接驱动真机探索（风险与不稳定性太大），而是把它用在三件更稳、更可交付的事上：
        </p>
        <ul>
          <li><b>数据筛选与加权（quality filtering / critic scoring）</b>：给轨迹打分、剔除低质量/不可复现数据、挑 hard cases（对应本文的 <code>quality</code>/<code>progress</code>/<code>failure_mode</code>）。</li>
          <li><b>复盘式自我改进（post-training / Offline RL / Recap）</b>：从成功与失败轨迹中学习“哪一步错了”，把失败当一等数据（对应本文的 <code>recoverability</code> 与 failure segmentation）。</li>
          <li><b>安全与可追责优先</b>：RM 先做 triage（排序/筛选/触发复核与恢复），最终验收仍绑定部署 KPI（SR/IR/ER + 失败分布 + 置信区间）。</li>
        </ul>
        <p>
          <b>公开对照（handbook）</b>：
          π*0.6 的 <b>Recap</b> 属于典型的 post-training / Offline RL 复盘范式；GR‑RL 体现了用 critic 筛选/提升长时程精细操作数据质量的思路；Reward Discovery 则对应“自动发现/进化奖励函数”的研究路线。
        </p>

        <h2 id="sync">7) 时间同步与数据管线（可训练 / 可复现 / 可追责）</h2>
        <ul>
          <li><b>统一时钟</b>：优先 PTP（IEEE 1588），并 timestamp-at-source。</li>
          <li><b>对齐策略</b>：以视觉帧为 anchor，Ring Buffer 对齐 <code>q/qdot/effort/current/tactile</code>。</li>
          <li><b>记录两条动作流（非常重要）</b>：命令流 <code>cmd_joint_target</code> + 执行流 <code>measured_q/measured_effort</code>。</li>
        </ul>
        <p>否则你无法判断失败到底是“策略错”，还是“执行延迟/饱和/保护触发”导致的。</p>

        <h4>同步实现要点（对应 handbook）</h4>
        <ul>
          <li>
            <b>Timestamp-at-source</b> + 统一时钟（PTP/NTP）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/multimodal_data_synchronization.md" target="_blank" rel="noopener noreferrer">multimodal_data_synchronization.md</a>
          </li>
          <li>
            <b>触觉集成的延迟/布线/标定成本</b>（视触觉尤其关键）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/tactile_sensor_integration_challenges.md" target="_blank" rel="noopener noreferrer">tactile_sensor_integration_challenges.md</a>
          </li>
        </ul>

        <h3 id="two-modes">7.1 Deploy vs Research：同一套数据骨架（Deploy = 子集，Research = 超集）</h3>
        <p>
          你选择的路线是 <b>A + C</b>：用 Research Mode 的视触觉提供“高信息 teacher 信号”，但部署（Deploy Mode）不依赖视触觉的 uptime。
          因此数据要做到：<b>同一套 schema</b>，Research 只是多字段，Deploy 允许缺字段。
        </p>
        <ul>
          <li><b>Deploy Mode（长时稳定、量大）</b>：<code>rgb_static</code> / <code>rgb_wrist</code> / <code>q</code> / <code>qdot</code> / <code>current/effort</code>（+ 可选 <code>wrist_FT</code>）</li>
          <li><b>Research Mode（高分辨、高信息、量小）</b>：在 Deploy schema 上加视触 teacher 模态。建议采用<b>多点视触</b>（指腹 + 侧边/侧壁为主），对应字段可按通道组织：<code>visuotactile_img*</code> / <code>tactile_depth*</code> / <code>contact_patch*</code>（例如按 <code>vt_pad</code>/<code>vt_side</code> 命名）。</li>
        </ul>

        <h4>共通字段（推荐）</h4>
        <ul>
          <li><b>动作两条流</b>：命令流 <code>cmd_joint_target</code> + 执行流 <code>measured_q</code>/<code>measured_effort</code></li>
          <li><b>episode metadata</b>：<code>task</code>、<code>calib_version</code>、<code>sync_status</code>、<code>replay_ok</code>、<code>sensor_health</code></li>
          <li><b>时间</b>：timestamp-at-source + 统一时钟 + Ring buffer 对齐（以相机为 anchor）</li>
        </ul>

        <h3 id="teacher-student">7.2 A：Teacher → Student（蒸馏到可部署信号）</h3>
        <p>
          目标：让部署侧只依赖可靠模态（RGB + proprio + current/effort + F/T），但仍能获得“类视触觉”的状态（接触模式、滑移风险、失败模式）。
          做法是：用 Research Mode 的视触 teacher 生成 teacher labels（建议多点视触：指腹 + 侧边/侧壁覆盖侧向受力与形变），再训练一个只吃 Deploy 模态的 Student estimator。
        </p>
        <h4>Teacher labels（最小集合）</h4>
        <ul>
          <li><b>接触与摩擦</b>：<code>contact_mode</code>（stick/slip/roll）、<code>slip_risk</code>（0–1）、<code>contact_confidence</code></li>
          <li><b>失败语义</b>：<code>failure_mode</code>（jam/slip/occlusion/misalignment/overforce…）</li>
          <li><b>RM-in-loop</b>：<code>progress</code>、<code>quality</code>、<code>recoverability</code></li>
        </ul>
        <p>
          <b>补充（与电手套/电皮肤的 teacher 更对齐）</b>：若你的 student 目标是拟合“包覆材料在外力变化下的侧向形变”，
          teacher 侧就不能只看单一指腹视角——建议把 teacher 的几何/接触模式标签基于 <b>pad + side</b> 两个（或以上）视触通道联合生成，并对侧向形变/脱离边缘等情况显式给出更高权重或单独事件标签。
        </p>
        <h4>部署侧推理（Student 输出给 policy）</h4>
        <ul>
          <li><b>输入</b>：Deploy 模态（RGB + q/qdot + current/effort + 可选 wrist_FT）</li>
          <li><b>输出</b>：teacher labels 的估计值（作为 VLA policy 的“可观测因果状态”）</li>
        </ul>

        <h4 id="state-taxonomy">7.2.1 因果状态空间（state taxonomy）：VLA 真正在学什么</h4>
        <p>
          从第一性原理出发，DexHand 不是“更复杂的夹爪”，而是机器人把语义意图转成可控的<b>物理因果</b>的接口。
          因此 policy 需要的不是“更多传感器”，而是一个可部署、可对齐、可回放的<b>因果状态</b>：
        </p>
        <ul>
          <li><b>接触几何（contact geometry）</b>：是否接触、接触点/接触面、接触面积、接触法向方向（或等价特征）</li>
          <li><b>力学因果（wrench / constraints）</b>：对物体施加的 \(w\)（或其可观测 proxy）、外部约束反力（推/拉/扭/撬）</li>
          <li><b>摩擦状态（friction state）</b>：<code>contact_mode</code>（stick/slip/roll）、<code>slip_risk</code></li>
          <li><b>失败语义（failure semantics）</b>：<code>failure_mode</code>（jam/slip/occlusion/misalignment/overforce…）</li>
          <li><b>可恢复性（recoverability）</b>：是否处于“可自救窗口”，以及推荐的恢复原语 <code>primitive</code></li>
        </ul>
        <p>
          这解释了 A（Teacher→Student）的必要性：Research Mode 的视触觉提供高信息的“因果真值”，而 Deploy Mode 则要把这些真值蒸馏成可部署信号。
        </p>

        <h4 id="teacher-labeling">7.2.2 Teacher labels 的产生机制（视触 → 标注 → 版本化）</h4>
        <p>
          这一步的目标是让 label <b>可计算、可复现、可版本化</b>，否则 teacher label 会变成不可追责的“拍脑袋标签”。
          推荐把每次生成 teacher label 的实现写成一个可追踪版本：<code>teacher_version</code>（commit hash / semantic version）+ <code>teacher_config</code>（阈值/窗口大小等）。
        </p>
        <table>
          <thead>
            <tr>
              <th>label</th>
              <th>定义（第一性）</th>
              <th>视触可计算 proxy（示例）</th>
              <th>输出形式</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>contact_confidence</code></td>
              <td>“是否接触”的置信度</td>
              <td>接触 patch 面积是否显著：<code>area(contact_patch) &gt; A_min</code></td>
              <td>0–1</td>
            </tr>
            <tr>
              <td><code>contact_patch</code></td>
              <td>接触区域（几何真值）</td>
              <td>由视触深度/形变图阈值得到二值 mask；可进一步取 centroid/主方向</td>
              <td>mask + stats</td>
            </tr>
            <tr>
              <td><code>contact_mode</code></td>
              <td>接触处于 stick/slip/roll（摩擦边界）</td>
              <td>
                <ol style="margin:0; padding-left: 1.1em;">
                  <li>若 <code>contact_confidence</code> 低 → no_contact</li>
                  <li>估计接触 patch 的切向位移/光流能量 \(v_t\)</li>
                  <li>若 \(v_t &gt; v_{slip}\) 且法向压入持续存在 → slip；否则 stick</li>
                  <li>若存在绕接触点显著旋转且切向位移小 → roll（可选）</li>
                </ol>
              </td>
              <td>枚举/one-hot</td>
            </tr>
            <tr>
              <td><code>slip_risk</code></td>
              <td>\(P(\\text{slip within }\\Delta t)\)</td>
              <td>用短窗口特征回归：<code>v_t</code>、接触面积变化、法向压入变化、effort/current 残差（如果同步）</td>
              <td>0–1</td>
            </tr>
            <tr>
              <td><code>failure_mode</code></td>
              <td>失败的物理原因分类</td>
              <td>
                <ul style="margin:0; padding-left: 1.1em;">
                  <li>jam：<code>current↑</code> + <code>qdot≈0</code></li>
                  <li>slip：<code>contact_mode=slip</code></li>
                  <li>misalignment：接触 patch 偏置且 progress 停滞</li>
                  <li>occlusion：视觉/视触关键观测缺失（可选）</li>
                </ul>
              </td>
              <td>多类分类</td>
            </tr>
            <tr>
              <td><code>progress</code></td>
              <td>子任务进度（用于切段/训练）</td>
              <td>用规则或小模型：达到关键状态（接触建立、稳定抓取、旋转完成…）</td>
              <td>0–1</td>
            </tr>
            <tr>
              <td><code>recoverability</code></td>
              <td>是否处于可自救窗口</td>
              <td>failure_mode + 接触置信度 + 安全事件组合判定</td>
              <td>0–1 或 bool</td>
            </tr>
            <tr style="background-color: rgba(20, 110, 190, 0.08);">
              <td colspan="4"><b>力学真值（精细力控必需）</b></td>
            </tr>
            <tr>
              <td><code>contact_wrench</code></td>
              <td>接触点的 6D 力/力矩估计</td>
              <td>视触形变 + <code>wrist_FT</code> 的联合估计（或基于形变的力学建模）</td>
              <td>[Fx, Fy, Fz, τx, τy, τz]</td>
            </tr>
            <tr>
              <td><code>grasp_stability_margin</code></td>
              <td>离摩擦锥边界的余量（安全距离）</td>
              <td>\(\mu f_n - |f_t|\) 的归一化（或基于 <code>slip_risk</code> 的逆推）</td>
              <td>0–1（1 = 非常稳定，0 = 即将滑移）</td>
            </tr>
            <tr>
              <td><code>insertion_phase</code></td>
              <td>插入任务的阶段状态</td>
              <td>基于 <code>wrist_FT</code> 特征 + 深度/接触面积变化：approach / contact / slide / jam / success</td>
              <td>枚举（5 类）</td>
            </tr>
            <tr>
              <td><code>twist_phase</code></td>
              <td>扭转任务的阶段状态</td>
              <td>基于 <code>wrist_FT.τz</code> + 角度变化：engage / turn / slip / complete</td>
              <td>枚举（4 类）</td>
            </tr>
            <tr>
              <td><code>normal_force</code></td>
              <td>接触法向力估计（单通道）</td>
              <td>视触压入深度 → 力（需标定）或 <code>wrist_FT.Fz</code> 投影</td>
              <td>标量（N）</td>
            </tr>
            <tr>
              <td><code>tangential_force</code></td>
              <td>接触切向力估计（单通道或 2D）</td>
              <td>视触剪切形变 → 力（需标定）或 <code>wrist_FT</code> 的 Fx/Fy 分量</td>
              <td>标量或 [fx, fy]（N）</td>
            </tr>
            <tr style="background-color: rgba(255, 193, 7, 0.08);">
              <td colspan="4"><b>场景特定增强（可选）</b></td>
            </tr>
            <tr>
              <td><code>material_class</code></td>
              <td>物体材质分类（基于热导率 + 视觉纹理）</td>
              <td>
                • 温度：接触后 dT/dt (0.5–2s 窗口) → 热导率估计<br>
                • 视觉：RGB 纹理特征（颜色/光泽/纹理）<br>
                • 联合：融合两者 → 分类 logits
              </td>
              <td>枚举：metal / plastic / wood / fabric / ceramic</td>
            </tr>
          </tbody>
        </table>
        <p>
          注意：视触不必承担高频闭环（handbook 强调其延迟/线缆/耗材/标定成本），但它非常适合在 Research Mode 里提供“几何真值”和“摩擦状态真值”。<br>
          对 Deploy Mode，teacher labels 只作为监督信号，不作为实时传感依赖。
        </p>

        <h4 id="materials-physics">7.2.2.1 材料/接触物理学：为什么“视触 teacher”必须做版本化与去材料化</h4>
        <p>
          视触（gel-based）之所以“信息量大”，是因为它把接触边界条件（法向压力、剪切、曲率、边缘）映射成可观测的形变/光学纹理；
          但这条映射<strong>不是常数</strong>，而是强烈依赖材料与环境：粘弹性、蠕变、滞回、温度、老化、污染都会改变同一个接触在传感器里的“表观形变”。
          因此在 Teacher→Student 里，视触更适合承担 <b>teacher（近真值）</b> 而不是 <b>线上依赖</b>，并且 teacher 必须显式建模“不确定度”和“版本”。
        </p>
        <ul>
          <li>
            <b>关键材料效应（会让 teacher label 漂）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li><b>粘弹性/滞回</b>：同样的压入深度，上升段与下降段形变不同；短窗口特征比单帧更可靠（否则会把“材料滞回”误判成接触模式变化）。</li>
              <li><b>蠕变/应力松弛</b>：保持接触时形变会随时间漂移；因此 <code>contact_confidence</code>/<code>slip_risk</code> 更应基于 \(\Delta t\) 窗口内的变化率与稳态残差。</li>
              <li><b>温度与老化</b>：模量变化会导致 <code>A_min</code>、<code>v_{slip}</code> 等阈值随批次/寿命变化；必须把 <code>gel_id</code>/<code>gel_batch</code>/<code>temp_gel</code>、以及 <code>calib_version</code> 记录为 metadata。</li>
              <li><b>表面污染/润滑</b>：会改变摩擦与光学特征（例如高光/雾化），需要输出 <code>contact_confidence</code> 与 <code>teacher_uncertainty</code>，并在 RM/QC 中触发复核。</li>
            </ul>
          </li>
          <li>
            <b>Teacher→Student 映射的工程原则（让 student 学到“物理因果”而不是“胶的纹理”）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li><b>输出低维因果状态 + 不确定度</b>：teacher 输出 <code>contact_mode</code>/<code>slip_risk</code>/<code>contact_patch_stats</code> 同时输出 <code>teacher_uncertainty</code>（或置信度），student 训练时对低置信样本降权。</li>
              <li><b>做“去材料化”的特征</b>：尽量用归一化/比值/变化率（例如 patch 面积的相对变化、切向位移能量的归一化）而不是绝对像素强度；减少对 gel 批次/光照的敏感性。</li>
              <li><b>预处理/预调理（pre-conditioning）</b>：每次开机或更换 gel，先跑固定的压入/滑动脚本做“材料状态初始化”，并写入 <code>precondition_ok</code>。</li>
              <li><b>把材料当作 nuisance 变量</b>：在 teacher config 里显式记录（gel/温度/光照/镜头），必要时按 batch 分组校准阈值，避免跨批次直接共享阈值。</li>
            </ul>
          </li>
        </ul>

        <h4 id="student-policy-interface">7.2.3 Student → Policy 的接口规格（让部署可控、可验证）</h4>
        <p>
          为了让 A 真正可落地，必须把 student 的输出形式“写死”，并规定 policy 如何消费这些输出（否则会出现训练/部署语义不一致）。
        </p>
        <ul>
          <li><b>Student 输入</b>：对齐后的 Deploy 模态（RGB + q/qdot + current/effort + 可选 wrist_FT）</li>
          <li><b>Student 输出（推荐最小集合）</b>：</li>
        </ul>
        <ul>
          <li><code>contact_mode_logits</code>（3 类：stick/slip/roll）</li>
          <li><code>slip_risk</code>（0–1）</li>
          <li><code>failure_mode_logits</code>（多类）</li>
          <li><code>progress</code>（0–1）</li>
          <li><code>recoverability</code>（0–1）</li>
        </ul>
        <p>
          <b>电传感的盲区：为什么“拉力（tension）”难直接感到？如何补齐？</b><br>
          多数电触觉/电手套对“压入/接触面积变化”（法向）很敏感，但对<strong>拉离/张力</strong>本身没有对称的直接通道（没有“负压力”这一物理量），
          往往只能通过“接触逐渐消失/边缘先脱离”的事件间接体现。这会导致仅靠电触觉很难稳定估计 pull load。<br>
          <b>工程解法（推荐优先级）</b>： (1) 加 <code>wrist_FT</code> 或关节力矩/腱张力传感，提供外力/拉力的可观测 proxy；(2) 用 <code>q/qdot + current/effort</code> 做模型外力估计（把摩擦/内阻作为不确定度处理）；(3) 把“脱离/将脱离”事件化为 <code>detach_risk</code>/<code>recoverability</code>，让 policy 在拉力任务中优先走“先建立足够法向，再拉”的原语序列。
        </p>
        <p>
          <b>Policy 使用约束（示例）</b>：
        </p>
        <ul>
          <li>若 <code>slip_risk</code> 高：优先触发“增大法向/调整接触几何/降速”类原语</li>
          <li>若 <code>failure_mode=jam</code> 且 <code>recoverability</code> 高：触发 backoff + reopen + re-approach</li>
          <li>若 <code>progress</code> 长时间停滞：切换原语（push→wedge→twist…）或触发重新定位</li>
        </ul>
        <p>
          这些规则也可以作为早期的 <b>rule-based policy</b>（阶段 1），随后逐步被 VLA policy 学到（阶段 2+）。
        </p>

        <h3 id="rm-qc">7.3 C：RM/QC flywheel（把部署数据变成“可用且可追责”的数据）</h3>
        <p>
          视触觉不必进 kHz 闭环，但可以显著提高数据质量与训练效率：QC、更准切段、更准 hard case 挖掘、更可控的恢复触发。
        </p>
        <ul>
          <li><b>QC</b>：Replay Validation（同一命令流重放能否重现成功）</li>
          <li><b>切段</b>：用 <code>progress</code>/<code>failure_mode</code> 进行 episode/subtask segmentation</li>
          <li><b>hard case</b>：用 <code>slip_risk</code>、接触模式变化、恢复触发点做 hard case mining</li>
          <li><b>恢复触发</b>：<code>recoverability</code> + <code>failure_mode</code> → 选择 recovery primitive（不要求视触觉进入 kHz）</li>
        </ul>

        <h4 id="replay-checklist">7.3.1 Replay Validation（最关键 QC）—可执行 checklist</h4>
        <p>目标：把“能不能训练”从主观判断变成硬指标。</p>
        <ul>
          <li><b>必须记录</b>：<code>cmd_joint_target</code>（命令流）与 <code>measured_q/measured_effort</code>（执行流），并带 <code>sync_status</code></li>
          <li><b>重放方式</b>：同一初始条件下重放命令流（或重放关键子段）</li>
          <li><b>判定指标</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>末端/关节轨迹误差（例如 \(\|q_{replay}-q_{ref}\|\) 的阈值）</li>
              <li>成败一致性（success label 一致）</li>
              <li>关键事件一致性（safety_trip/jam 事件是否一致）</li>
            </ul>
          </li>
          <li><b>产出</b>：写入 <code>replay_ok</code>（bool）与 <code>replay_score</code>（0–1，可选）</li>
        </ul>

        <h4 id="ac-mermaid">A+C 数据流（示意图）</h4>
        <pre><code>flowchart TD
  DeployMode[DeployMode_Data] --> Align[TimeSync_Align]
  ResearchMode[ResearchMode_Data_WithVisuoTactile] --> Align

  ResearchMode --> Teacher[TeacherLabeler_VisuoTactile]
  Teacher --> Labels[TeacherLabels]

  DeployMode --> Student[StudentEstimator_DeployOnly]
  Labels --> Student

  Student --> PolicyInputs[VLA_Policy_Inputs]
  DeployMode --> PolicyInputs

  PolicyInputs --> Policy[VLA_Policy]

  DeployMode --> RM[RM_QC_Flywheel]
  ResearchMode --> RM
  RM --> HardCases[HardCaseMining]
  HardCases --> Train[Retrain]
  Train --> Student
  Train --> Policy</code></pre>

        <h3 id="data-collection-workflow">7.4 数据采集实施流程（VLA公司落地操作指南）</h3>
        <p>
          本节面向"买完系统回去要做什么"的实际工程问题：<b>谁来采、怎么采、采什么、如何质控、如何从 Research 过渡到 Deploy</b>。
          流程按照 <a href="#plan">9.2 迭代路线图</a> 的阶段划分，每个阶段给出可执行的操作清单。
        </p>

        <h4 id="day0">Day 0：系统初始设置（开箱到第一条数据）</h4>
        <p><b>目标</b>：验证硬件、建立数据管线、完成首次标定，产出第一条可回放的 episode。</p>

        <h5>硬件检查清单（MVS最小配置）</h5>
        <table>
          <thead>
            <tr>
              <th>检查项</th>
              <th>验证方法</th>
              <th>产出/记录</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>2 路 RGB 相机</td>
              <td>采集 10 帧，检查分辨率、帧率、曝光一致性</td>
              <td><code>camera_calib_v1.yaml</code>（内参/外参/畸变）</td>
            </tr>
            <tr>
              <td>关节位置/速度</td>
              <td>运动全行程，检查 <code>q/qdot</code> 连续性、无跳变</td>
              <td><code>joint_limits.yaml</code>（软硬限位）</td>
            </tr>
            <tr>
              <td>电流/力矩 proxy</td>
              <td>空载/负载对比，建立 <code>current_baseline</code></td>
              <td><code>current_calib_v1.json</code>（零点/增益）</td>
            </tr>
            <tr>
              <td>时间同步</td>
              <td>检查 PTP/NTP 状态，timestamp 对齐误差 &lt; 5ms</td>
              <td><code>sync_status: ok</code> 写入 metadata</td>
            </tr>
            <tr>
              <td>Level-A 安全反射</td>
              <td>触发过流/过热/碰撞，验证 <code>backoff</code> 响应</td>
              <td><code>safety_config_v1.yaml</code></td>
            </tr>
          </tbody>
        </table>

        <h5>Day 0 产出（必须完成才能进入阶段 1）</h5>
        <ul>
          <li><code>calib_version: v1.0.0</code>（标定文件版本化，写入 git/hash）</li>
          <li>第一条可回放 episode（<code>replay_ok: true</code>）</li>
          <li>数据 schema 定义（<code>episode_schema_v1.json</code>）</li>
          <li>Replay Validation 脚本（自动化验证 <code>replay_ok</code>）</li>
        </ul>

        <h4 id="stage1-collection">阶段 1（2–4 周）：MVS 基础数据采集</h4>
        <p>
          <b>硬件配置</b>：2 路 RGB + q/qdot + current/effort<br>
          <b>能力范围</b>：简单抓取、pick-and-place、粗防滑<br>
          <b>数据目标</b>：1000–3000 episodes（成功率 60–80%），建立数据质量基线
        </p>

        <h5>采集流程（谁来采）</h5>
        <table>
          <thead>
            <tr>
              <th>采集方式</th>
              <th>适用场景</th>
              <th>数据量占比</th>
              <th>质量特点</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>遥操作（teleoperation）</b></td>
              <td>冷启动、复杂任务、hard cases</td>
              <td>30–50%</td>
              <td>高质量，但慢（5–10 episodes/小时）</td>
            </tr>
            <tr>
              <td><b>规则策略（scripted policy）</b></td>
              <td>简单抓取、标准场景</td>
              <td>30–40%</td>
              <td>一致性高，但泛化弱</td>
            </tr>
            <tr>
              <td><b>自主探索（w/ RM 筛选）</b></td>
              <td>阶段 2+ 解锁，用于数据飞轮</td>
              <td>20–30%（阶段 1 占比低）</td>
              <td>量大，需 RM QC</td>
            </tr>
          </tbody>
        </table>

        <h5>每条 episode 必须记录的字段（episode metadata）</h5>
        <pre><code>{
  "episode_id": "ep_20260115_001234",
  "task": "pick_cup",
  "collection_method": "teleoperation",  # teleoperation / scripted / autonomous
  "calib_version": "v1.0.0",
  "sync_status": "ok",                   # ok / degraded / failed
  "replay_ok": true,                     # Replay Validation 结果
  "success": true,                       # 任务是否成功
  "failure_mode": null,                  # jam / slip / occlusion / timeout / ...
  "duration_sec": 12.5,
  "sensor_health": {"rgb_static": "ok", "rgb_wrist": "ok", "current": "ok"},
  "timestamp_start": 1736899234.567,
  "git_commit": "a1b2c3d"                # 代码版本
}</code></pre>

        <h5>阶段 1 数据质量控制（每天/每周执行）</h5>
        <ol>
          <li><b>Replay Validation</b>：抽查 10% episodes，<code>replay_ok</code> 通过率 &gt; 90%</li>
          <li><b>失败分布统计</b>：<code>failure_mode</code> 统计（哪类失败最多？是否需要调整采集策略？）</li>
          <li><b>成功率监控</b>：按任务类型分组，SR（Success Rate）&gt; 60%；若 SR 持续下降→检查标定漂移</li>
          <li><b>传感器健康</b>：每天开机前检查 <code>sensor_health</code>，异常立即重新标定</li>
        </ol>

        <h5>阶段 1 产出（进入阶段 2 的前置条件）</h5>
        <ul>
          <li>1000+ 可复现 episodes（<code>replay_ok: true</code>）</li>
          <li>规则 RM v1.0（基于 current/effort 阈值的 <code>contact_mode</code>/<code>slip_risk</code> 伪标签）</li>
          <li>失败分布 baseline（后续用于 A/B 对比）</li>
        </ul>

        <h4 id="stage2-collection">阶段 2–2.5（6–10 周）：加入 wrist_FT，解锁精细力控</h4>
        <p>
          <b>硬件新增</b>：1 个手腕 6D F/T 传感器（≥200Hz）<br>
          <b>新增能力</b>：<code>twist</code>（拧瓶盖）、<code>insertion</code>（精密插入）、<code>pry</code>（撬开）、<code>pull</code>（拉力闭环）<br>
          <b>数据目标</b>：每类新任务 200–500 episodes
        </p>

        <h5>wrist_FT 标定流程（Day 1）</h5>
        <ol>
          <li><b>零点标定</b>：手空载静止，采集 1000 帧 → 计算 <code>wrist_FT_zero_offset</code></li>
          <li><b>重力补偿标定</b>：手臂多姿态（6–10 个姿态），建立重力模型 → <code>gravity_comp_model_v1.json</code></li>
          <li><b>已知负载验证</b>：抓取已知质量物体（100g, 500g, 1kg），验证 Fz 读数误差 &lt; 5%</li>
          <li><b>扭矩标定</b>（可选）：用标准力矩扳手施加已知扭矩，验证 τz 读数</li>
        </ol>

        <h5>精细力控任务的采集要点</h5>
        <table>
          <thead>
            <tr>
              <th>任务原语</th>
              <th>关键采集信号</th>
              <th>成功判据（自动标注）</th>
              <th>推荐采集方式</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>twist</code></td>
              <td><code>wrist_FT.τz</code> + 角度变化</td>
              <td>旋转达标 且 <code>slip_risk &lt; 0.3</code></td>
              <td>遥操作（初期），脚本（标准瓶盖）</td>
            </tr>
            <tr>
              <td><code>insertion</code></td>
              <td><code>wrist_FT</code> (6D) + 深度</td>
              <td>插入深度达标 且 无 <code>jam</code></td>
              <td>遥操作 + RM 辅助对中</td>
            </tr>
            <tr>
              <td><code>pry</code></td>
              <td><code>wrist_FT</code> (6D) + 安全限位</td>
              <td>约束解除 且 无 <code>safety_trip</code></td>
              <td>遥操作（高风险，慢速采集）</td>
            </tr>
            <tr>
              <td><code>pull</code></td>
              <td><code>wrist_FT.Fz</code> + 位移</td>
              <td>拉力达标 且 无脱手</td>
              <td>脚本（简单）+ 遥操作（复杂）</td>
            </tr>
          </tbody>
        </table>

        <h5>阶段 2.5 数据质量升级</h5>
        <ul>
          <li><b>新增 teacher label</b>：<code>contact_wrench</code>（6D 力/力矩）、<code>twist_phase</code>、<code>insertion_phase</code></li>
          <li><b>RM 升级</b>：从规则阈值 → 轻量学习模型（基于阶段 1 数据训练，替换硬编码阈值）</li>
          <li><b>自动切段</b>：用 <code>progress</code>/<code>primitive</code> 做 subtask segmentation（一条 episode 切成多个 subtask）</li>
        </ul>

        <h5>阶段 2.5 产出</h5>
        <ul>
          <li>精细力控任务库：每类任务 200+ episodes</li>
          <li><code>wrist_FT_calib_v2.json</code>（含重力补偿）</li>
          <li>RM v2.0（轻量模型，替换规则阈值）</li>
        </ul>

        <h4 id="stage3-4-collection">阶段 3–4（2–6 月）：指尖力 + 视触觉 Teacher</h4>
        <p>
          <b>阶段 3 硬件新增</b>：2 个指尖 3 轴力传感器<br>
          <b>阶段 4 硬件新增</b>：多点视触觉（指腹 + 侧边，Research Mode only）<br>
          <b>目标</b>：形成完整 Teacher→Student 数据飞轮
        </p>

        <h5>Research Mode vs Deploy Mode 数据采集策略</h5>
        <table>
          <thead>
            <tr>
              <th>模式</th>
              <th>传感器配置</th>
              <th>采集目的</th>
              <th>数据量</th>
              <th>质量要求</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Deploy Mode</b></td>
              <td>RGB + q/qdot + current/effort + wrist_FT（+ 指尖力）</td>
              <td>量产数据，训练 Policy + Student</td>
              <td>大（5000+）</td>
              <td><code>replay_ok</code> + SR 基线</td>
            </tr>
            <tr>
              <td><b>Research Mode</b></td>
              <td>Deploy 配置 + 多点视触（pad+side）</td>
              <td>生成高质量 teacher labels</td>
              <td>中（1000–2000）</td>
              <td>Teacher label 置信度 + 覆盖 hard cases</td>
            </tr>
          </tbody>
        </table>

        <h5>视触觉 Teacher 标定与数据采集（阶段 4）</h5>
        <ol>
          <li>
            <b>Teacher 标定（每次更换 gel 必做）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>记录 <code>gel_id</code> / <code>gel_batch</code> / <code>gel_install_date</code></li>
              <li>预调理（pre-conditioning）：运行标准压入/滑动脚本，验证 <code>precondition_ok</code></li>
              <li>标定接触阈值：<code>A_min</code>（最小接触面积）、<code>v_slip</code>（滑移速度阈值）</li>
              <li>版本化：<code>teacher_version: v2.1.0</code> + <code>teacher_config</code>（阈值参数）</li>
            </ul>
          </li>
          <li>
            <b>采集策略（Research Mode）</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>优先采集 Deploy Mode 中失败率高的任务（hard cases）</li>
              <li>每条 episode 同时记录 Deploy 模态 + 视触觉图像</li>
              <li>Teacher labeler 实时生成 <code>contact_mode</code> / <code>slip_risk</code> / <code>contact_patch</code> / <code>teacher_uncertainty</code></li>
              <li>低置信样本（<code>teacher_uncertainty &gt; 0.3</code>）标记为待复核</li>
            </ul>
          </li>
          <li>
            <b>Teacher→Student 训练</b>：
            <ul style="margin: 0.3em 0 0 0; padding-left: 1.1em;">
              <li>输入：Deploy 模态（RGB + q/qdot + current/effort + wrist_FT）</li>
              <li>监督信号：Teacher labels（带不确定度加权）</li>
              <li>验证：在 Deploy Mode 数据上测试 Student 输出与 RM 规则的一致性</li>
              <li>闭环验收：把 Student 输出接到 recovery primitives，测量 SR/IR 提升</li>
            </ul>
          </li>
        </ol>

        <h5>阶段 4 产出（完整数据飞轮）</h5>
        <ul>
          <li>Teacher labeler v1.0（可版本化、可复现）</li>
          <li>Student estimator v1.0（Deploy Mode 可用）</li>
          <li>Research Mode 数据集（1000–2000 episodes，带高质量 teacher labels）</li>
          <li>Deploy Mode 数据集（5000+ episodes，用于训练 Policy）</li>
          <li>RM v3.0（学习型 critic，用于 QC 与 hard case mining）</li>
        </ul>

        <h4 id="data-qa-protocol">跨阶段数据质量保障协议</h4>
        <p><b>每日检查（自动化脚本）</b>：</p>
        <ul>
          <li><code>replay_ok</code> 通过率（目标 &gt; 90%）</li>
          <li><code>sync_status</code> 异常率（目标 &lt; 5%）</li>
          <li><code>sensor_health</code> 异常计数（任何异常立即触发重新标定）</li>
        </ul>

        <p><b>每周复盘（人工 + RM 辅助）</b>：</p>
        <ul>
          <li>失败分布变化（是否出现新 failure_mode？）</li>
          <li>SR/IR/ER 趋势（是否下降？→ 检查标定漂移或环境变化）</li>
          <li>Hard cases 挖掘（RM 排序后人工复核 top-20）</li>
        </ul>

        <p><b>阶段切换验收（A/B 对比）</b>：</p>
        <ul>
          <li>新硬件加入后，先在<b>交错模式</b>下采集 100 episodes（50 用新配置，50 用旧配置）</li>
          <li>对比 SR/IR/ER + 失败分布，验证新硬件带来的能力提升</li>
          <li>若新配置 SR 显著下降→检查标定或动力学变化（例如加 wrist_FT 后质量/惯量改变）</li>
        </ul>

        <h4 id="data-management">数据管理与版本控制</h4>
        <h5>数据存储结构（推荐）</h5>
        <pre><code>data/
├── raw/                          # 原始采集数据（不可修改）
│   ├── stage1_mvs/
│   │   ├── ep_20260115_001234/   # 每个 episode 一个文件夹
│   │   │   ├── metadata.json     # episode metadata
│   │   │   ├── rgb_static.mp4    # 视频或图像序列
│   │   │   ├── rgb_wrist.mp4
│   │   │   ├── proprio.h5        # q/qdot/current/effort 时间序列
│   │   │   └── commands.h5       # cmd_joint_target（命令流）
│   │   └── ...
│   ├── stage2_wrist_ft/
│   └── stage4_research_mode/
├── processed/                    # 处理后数据（对齐、标注）
│   ├── aligned/                  # 时间对齐后
│   ├── labeled/                  # Teacher labels
│   └── filtered/                 # QC 筛选后（replay_ok=true）
├── calibration/                  # 标定文件（版本化）
│   ├── v1.0.0/
│   │   ├── camera_calib_v1.yaml
│   │   ├── current_calib_v1.json
│   │   └── calib_hash.txt        # git commit hash
│   └── v2.0.0/
└── models/                       # RM / Student / Policy checkpoints
    ├── rm_v1.0.ckpt
    ├── student_v1.0.ckpt
    └── policy_v1.0.ckpt</code></pre>

        <h5>版本控制实践</h5>
        <ul>
          <li><b>标定文件</b>：每次重新标定 → 新版本号 + git commit</li>
          <li><b>Episode metadata</b>：必须记录 <code>calib_version</code> / <code>teacher_version</code> / <code>git_commit</code></li>
          <li><b>Teacher labeler</b>：代码版本化（git tag），配置文件版本化（semantic version）</li>
          <li><b>数据集发布</b>：每个阶段结束后发布"冻结版本"（例如 <code>dataset_stage1_v1.0</code>），用于后续 A/B 对比</li>
        </ul>

        <h4 id="common-pitfalls">常见采集陷阱与对策</h4>
        <table>
          <thead>
            <tr>
              <th>陷阱</th>
              <th>表现</th>
              <th>根因</th>
              <th>对策</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>标定漂移</b></td>
              <td>SR 逐渐下降，<code>slip_risk</code> 误报增加</td>
              <td>温度变化、gel 老化、零点漂移</td>
              <td>每天开机预调理；每周重新标定零点；记录 <code>gel_batch</code> 与使用时长</td>
            </tr>
            <tr>
              <td><b>Teacher 过拟合 gel</b></td>
              <td>Student 在新批次 gel 上性能下降</td>
              <td>Teacher labels 对材料特性敏感</td>
              <td>输出 <code>teacher_uncertainty</code>；低置信样本降权；做"去材料化"特征（归一化/比值）</td>
            </tr>
            <tr>
              <td><b>时间对齐失败</b></td>
              <td><code>replay_ok: false</code> 比例高</td>
              <td>传感器时钟不同步、Ring Buffer 溢出</td>
              <td>验证 PTP 状态；减小 Ring Buffer 窗口；timestamp-at-source</td>
            </tr>
            <tr>
              <td><b>RM 指标带偏</b></td>
              <td>RM 分数高但 SR 不提升</td>
              <td>RM 学到了"看起来好"而不是"真的好"</td>
              <td>验收绑定部署 KPI（SR/IR/ER）；RM 只做排序/筛选，不做唯一判据</td>
            </tr>
            <tr>
              <td><b>Hard cases 采集不足</b></td>
              <td>Policy 在边缘情况失败</td>
              <td>遥操作偏好简单任务，复杂情况数据少</td>
              <td>RM hard case mining → 优先采集失败场景；专门安排"刁钻场景"采集日</td>
            </tr>
          </tbody>
        </table>

        <h2 id="maintain">8) 标定、健康监测与可维护性</h2>
        <ul>
          <li><b>版本化标定资产</b>：<code>calib_version</code> / <code>calib_hash</code> 写进每条 episode metadata。</li>
          <li><b>触觉标定</b>：零点漂移、材料老化是常态；把 <code>recalib_required</code> 当作系统状态而不是人工备忘录。</li>
          <li><b>健康状态事件化</b>：用 <code>sensor_health</code>（drift/aging/dropout）驱动降额逻辑与维护节奏。</li>
        </ul>

        <h2 id="roadmap">9) 最小落地版与迭代路线图（走向超越人类）</h2>
        <h3 id="mvp">9.1 最小落地版本（你今天就能做出来）</h3>
        <ul>
          <li><b>硬件</b>：2 路 RGB（static + wrist）+ <code>effort/current</code> + <code>q/qdot</code>。</li>
          <li><b>软件</b>：统一时钟、对齐、Level-A 安全反射、Replay Validation。</li>
          <li><b>数据</b>：命令流 + 执行流 + episode metadata（sync/replay/calib）。</li>
        </ul>

        <h3 id="plan">9.2 迭代路线图</h3>
        <p><b>关键调整</b>：将 <code>wrist_FT</code> 提前到阶段 2.5，使精细力控任务（twist/insertion/pry）能够尽早解锁。</p>
        <ul>
          <li><b>阶段 1（2–4 周）</b>：MVS + Replay Validation + 规则 RM。<br>
            <em>能力范围</em>：简单抓取、pick-and-place、基于 current/effort 的粗防滑。</li>
          <li><b>阶段 2（2–4 周）</b>：规则伪标签训练成轻量 RM（替换阈值）。<br>
            <em>能力范围</em>：同阶段 1，但数据质量与自动切段能力提升。</li>
          <li><b>阶段 2.5（4–6 周）</b>：<b>加 1 个手腕 F/T（6D，≥200Hz）</b>，解锁精细力控原语。<br>
            <em>新增能力</em>：<code>twist</code>（擰瓶盖）、<code>insertion</code>（精密插入）、<code>pry</code>（撬开）、<code>pull</code>（拉力闭环）。<br>
            <em>理由</em>：这些任务需要扭矩/侧向力的精确闭环，<code>current/effort</code> 的弱 proxy 无法满足毫牛级精度要求。</li>
          <li><b>阶段 3（1–2 月）</b>：加 2 个指尖 3 轴力传感器（法向 + 切向），强化精细夹持。<br>
            <em>新增能力</em>：脆弱物抓取（毫牛级法向控制）、精细防滑（直接测量指尖摩擦状态）。</li>
          <li><b>阶段 4（长期）</b>：加多点视触觉（至少指腹 + 侧边/侧壁，用于 teacher），形成完整数据飞轮。<br>
            <b>可选增强</b>：加 1–2 个温度传感器（指尖侧面/手腕），用于材质识别与安全检测。<br>
            <em>新增能力</em>：
            <ul style="margin: 0.3em 0; padding-left: 1.5em;">
              <li>高品质 teacher labels（接触几何/接触模式/力学真值）</li>
              <li>显著提升 RM/QC 质量</li>
              <li>（温度）材质分类 (metal/plastic/wood/fabric) → 调整抓取策略</li>
              <li>（温度）热安全检测（过热预警，避免烫伤/损坏）</li>
            </ul>
            <em>适用场景</em>：通用家庭服务（温度可选）、厨房/医疗应用（温度推荐）。</li>
        </ul>
        <blockquote>
          <p>
            <b>为什么这样排序</b>：阶段 1–2 建立数据底座（可复现、可追责）；阶段 2.5 解锁精细力控（扩展任务谱系）；
            阶段 3 强化精细夹持（降低损坏风险）；阶段 4 提升数据质量（teacher 真值）。这样既保证了快速交付 MVS，又不让精细力控能力等到"长期"才上线。
          </p>
        </blockquote>

        <h2 id="feasibility">10) 可行性与未来性（面向 VLA 的评估结论）</h2>
        <p>
          本节给出一个“面试可复述”的结论：这套 DexHand Sensing System 方案的<strong>底座（多频闭环 + MVS）</strong>成熟且可快速交付；
          完整版（Teacher→Student + RM-in-loop）具有很强的“前沿 VLA 对齐度”，但通常需要以标签质量与 domain gap 为中心做<strong>数月级工程迭代</strong>（具体取决于既有控制栈、采数基础与人力投入）。
        </p>

        <h3 id="feasibility-why">10.1 核心架构的可行性（为什么能跑）</h3>
        <ul>
          <li><b>多频闭环分层（Level‑A/B/C）</b>：把 kHz 止损与 100Hz 接触稳定留给控制闭环，把 VLA 放在 5–15Hz 的原语接口上，符合前沿 VLA 的推理延迟与动作生成范式约束（Token/Diffusion/Flow）。</li>
          <li><b>Teacher→Student（A）</b>：Research 用多点视触（pad+side）提供接触几何/接触模式真值，Student 仅吃 Deploy 模态推理出低维因果状态，避免部署依赖脆弱 teacher 硬件。</li>
          <li><b>RM-in-loop（C）</b>：把 RM 定位为 data QC 与 hard-case triage（而非在线 RL reward），与前沿的 critic/Recap（post-training）路线对齐，并与 VLA 的“高质量数据 + 可靠评估”痛点对齐。</li>
        </ul>

        <h3 id="trl">10.2 关键模块成熟度（TRL/风险速览）</h3>
        <table>
          <thead>
            <tr>
              <th>模块</th>
              <th>成熟度（直观）</th>
              <th>主要风险</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>多频闭环 + proprio（q/qdot）</td>
              <td>高</td>
              <td>低（工程成熟）</td>
            </tr>
            <tr>
              <td><code>current/effort</code> 触觉代理</td>
              <td>中高</td>
              <td>中（需针对具体手/任务标定，避免误触发）</td>
            </tr>
            <tr>
              <td>多点视触 teacher（pad+side）</td>
              <td>中</td>
              <td>高（材料/温度/污染/老化导致标签漂移，需要版本化 + 不确定度）</td>
            </tr>
            <tr>
              <td>Teacher→Student 蒸馏</td>
              <td>中</td>
              <td>高（domain gap：Research→Deploy 分布偏移）</td>
            </tr>
            <tr>
              <td>RM-in-loop 自动 QC</td>
              <td>中低</td>
              <td>高（指标带偏风险；建议 RM 只做 triage，验收用部署 KPI）</td>
            </tr>
          </tbody>
        </table>

        <h3 id="mvs-feasibility">10.3 MVS（最小可行版本）为什么很值钱</h3>
        <p>
          MVS（2 路 RGB + q/qdot + current/effort + 同步对齐 + Replay Validation）能快速把系统从“demo”推进到“可回放、可追责、可迭代”。
          对 VLA 来说，这一步解决的是数据质量与评估协议的地基问题：没有 replay_ok 与失败分布，你无法严谨筛选 checkpoint，也无法做可靠 A/B。
        </p>

        <h3 id="risks">10.4 最大风险与对应对策（抓住真正会翻车的点）</h3>
        <ul>
          <li><b>Teacher 标签一致性</b>：把标签定义写成可执行代码（阈值 + 时间窗 + 版本号），并做跨环境/跨批次一致性检查；低置信样本降权。</li>
          <li><b>Domain gap（Research→Deploy）</b>：Research 装 teacher 后改变动力学边界的风险要显式评估（A/B 交错测试）；训练侧做 domain randomization / 自监督对齐；部署侧坚持只吃可长期信号。</li>
          <li><b>RM 指标带偏</b>：RM 先用规则起步，只做排序/筛选；最终验收绑定 SR/IR/ER + 失败类型分布 + 置信区间，并采用交错 A/B 与 reset-free 协议。</li>
        </ul>

        <h3 id="execution-plan">10.5 建议的落地顺序（不绑时间）</h3>
        <p>
          注：这里给的是“先后顺序”，不写周级承诺（不同公司/团队的控制栈、硬件改动窗口与人力差异很大）。
          若地基缺失，先补齐 A/B 的基本保护与 recover primitives、以及可写入的日志/时间同步，再往后推进。
        </p>
        <ul>
          <li><b>阶段 A（地基）</b>：MVS + 时间同步 + Replay Validation（先证明数据管线能跑、数据可追责）。</li>
          <li><b>阶段 B（伪 teacher）</b>：规则/阈值 teacher（先生成 <code>contact_mode</code>/<code>slip_risk</code> 的伪标签，定义版本化与不确定度接口）。</li>
          <li><b>阶段 C（student 上线）</b>：训练 Student，量化 teacher→student 信息损失；把输出接到 recover primitives 做闭环验收（SR/IR/ER + 失败分布）。</li>
          <li><b>阶段 D（真 teacher）</b>：接入多点视触 teacher（pad+side）做真 teacher；交错 A/B 验证数据质量与 KPI 提升，再逐步替换伪 teacher。</li>
          <li><b>阶段 E（RM/QC 升级）</b>：RM 从规则 triage 升级为学习型 critic/quality model，但验收仍绑定部署 KPI（避免指标带偏）。</li>
        </ul>

        <h2 id="refs">参考链接</h2>
        <ul>
          <li>
            多模态同步（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/multimodal_data_synchronization.md" target="_blank" rel="noopener noreferrer">multimodal_data_synchronization.md</a>
          </li>
          <li>
            触觉集成挑战（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/tactile_sensor_integration_challenges.md" target="_blank" rel="noopener noreferrer">tactile_sensor_integration_challenges.md</a>
          </li>
          <li>
            灵巧手采数（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/deployment/dexterous_hand_data_collection.md" target="_blank" rel="noopener noreferrer">dexterous_hand_data_collection.md</a>
          </li>
          <li>
            触觉传感器路线与工程取舍（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/product/sensors.md" target="_blank" rel="noopener noreferrer">product/sensors.md</a>
          </li>
          <li>
            触觉与 VLA（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/theory/tactile_vla.md" target="_blank" rel="noopener noreferrer">theory/tactile_vla.md</a>
          </li>
          <li>
            前沿：π*0.6 Recap（post-training / Offline RL 复盘）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/theory/pi0_6_dissection.md" target="_blank" rel="noopener noreferrer">theory/pi0_6_dissection.md</a>
          </li>
          <li>
            前沿：RL/critic/Recap 综述（handbook）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/theory/reinforcement_learning.md" target="_blank" rel="noopener noreferrer">theory/reinforcement_learning.md</a>
          </li>
          <li>
            前沿：数据飞轮与跨模态迁移（含 Reward Discovery / Recap 线索）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/theory/frontier/data_flywheel_and_cross_modal.md" target="_blank" rel="noopener noreferrer">theory/frontier/data_flywheel_and_cross_modal.md</a>
          </li>
          <li>
            前沿：Reward Discovery（奖励函数自主发现）：
            <a href="https://github.com/sou350121/vla-interview-handbook/blob/main/theory/frontier/reward_discovery_rl.md" target="_blank" rel="noopener noreferrer">theory/frontier/reward_discovery_rl.md</a>
          </li>
        </ul>
      </div>

      <div id="footer" style="display:flex; justify-content:flex-start; align-items:center; gap: 1em; flex-wrap: wrap; padding: 2em 0;">
        <div>&copy; 2025 Sou Kit-Wa (Ken). All rights reserved.</div>
      </div>
    </div>

    <script>
      (function() {
        var savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') document.body.classList.add('dark-theme');
      })();
    </script>
  </body>
</html>
